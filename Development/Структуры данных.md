#### Основные структуры данных
- Массив
- Стек
- Очередь
- Связный список
- Хэш таблица
- Дерево
- Двоичное дерево поиска
- Куча
- Граф

#### Временная сложность основных оперций
|Структура данных|Поиск|Чтение|Вставка|Удаление|
|------------|:------:|:--------:|:--------:|:-----------:|
|Массив|O(n)|O(1)|O(n)|O(n)|
|Стек|O(n)|O(n)|O(1)|O(1)|
|Очередь|O(n)|O(n)|O(1)|O(1)|
|Связный список|O(n)|O(n)|O(1)|O(1)|
|Хэш таблица|O(1)| - |O(1)|O(1)|
|Двоичное дерево поиска(BST)|O(log N)|O(log N)|O(log N)|O(log N)|

||Поиск максимума|Извлечение максимума|Вставка|Удаление|
|------------|:------:|:--------:|:--------:|:-----------:|
|Двоичная куча|О(1)|O(log N)|O(log N)|O(log N)|

#### Массив
|Структура данных|Поиск|Чтение|Вставка|Удаление|
|------------|:------:|:--------:|:--------:|:-----------:|
|Массив|O(n)|O(1)|O(n)|O(n)|

>[!info] Массив — это структура данных, которая сохраняет элементы с индексами в непрерывном блоке памяти.

Список Python представляет собой неоднородный массив переменной длины.


#### Стек
||Поиск|Чтение|Вставка|Удаление|
|------------|:------:|:--------:|:--------:|:-----------:|
|Стек|O(n)|O(n)|O(1)|O(1)|

>[!info] Last-In-First-Out. Стек — это абстрактный тип данных и линейная структура данных, которая позволяет удалять только последний добавленный элемент. Можно представить себе стек в образе стопки книг

```
# Пример реализации на основе листа
class ListStack:
    def __init__(self):
        self._L = []

    def push(self, item):            # добавление нового элемента в стек
        self._L.append(item)

    def pop(self):                   # возврат и удаление элемента(LIFO)
        return self._L.pop()

    def peek(self):                  # возврат элемента(LIFO)
        return self._L[-1]

    def __len__(self):               # число элементов в стеке
        return len(self._L)

    def isempty(self):               # возвращает True, если стек пуст
        return len(self) == 0
```

###### Когда использовать
- Проталкивание элементов в стек и выталкивание из него имеют временную сложность О(1). 
- Стеки эффективны для добавления и удаления данных, но не так эффективны для операций, требующих доступа ко всему стеку.
- Стек — одна из наиболее востребованных структур данных при обработке данных. 
- Применяют стеки для реализации алгоритмов поиска в ширину, чтобы искать данные в деревьях и графах.

#### Очередь
||Поиск|Чтение|Вставка|Удаление|
|------------|:------:|:--------:|:--------:|:-----------:|
|Очередь|O(n)|O(n)|O(1)|O(1)|

>[!info] First-In-First-Out. Очереди - это массивы с тремя ограничениями:
>- данные могут вставляться только в конец очереди
>- удалить из очереди можно только первый элемент
>- прочитать можно только первый элемент очереди

В Python есть своя двунаправленная очередь. Быстрая вставка. Быстрое чтение. Потокобезопасная.  
Создание из списка с ограничением максимальной длины. При вставке лишнего значения, уже существ. там выпадет с другой стороны.

```
from collections import deque

dec = deque([1, 2, 3], maxlen=3)

dec.append(1)
dec.appendleft(2)
dec.pop(1)
dec.popleft(2)
```

###### Когда использовать

Очередь - идеальный инструмент для обработки асинхронных за­просов: она гарантирует, что запросы будут обрабатываться в том порядке, в котором были получены. Часто она применяется и для моделирования реаль­ных сценариев, где события должны происходить в определенном порядке.

#### Связный список
||Поиск|Чтение|Вставка|Удаление|
|------------|:------:|:--------:|:--------:|:-----------:|
|Связный список|O(n)|O(n)|O(n)/O(1) в начале|O(n)/O(1) в начале|

>[!info] Связный список представляет собой еще одну реализацию списка. Связный список имеет цепочку узлов, каждый из которых содержит фрагмент данных и информацию о местоположении следующего узла в цепи.

```
class ListNode:
    def __init__(self, data, link = None):
        self.data = data
        self.link = link

class LinkedList:
    def __init__(self):
        self._head = None
        self._tail = None
        self._length = 0
        
    def addfirst(self, item):
        self._head = ListNode(item, self._head)
        if self._tail is None: self._tail = self._head
        self._length += 1
        
    def addlast(self, item):
        if self._head is None:
            self.addfirst(item)
        else:
            self._tail.link = ListNode(item)
			self._tail = self._tail.link
			self._length += 1
			
	def removefirst(self):
		item = self._head.data
		self._head = self._head.link
		if self._head is None: self._tail = None
		self._length -= 1
		return item
		
	def removelast(self):
		if self._head is self._tail:
			return self.removefirst()
		else:
			currentnode = self._head
			
		while currentnode.link is not self._tail:
			currentnode = currentnode.link
		item = self._tail.data
		self._tail = currentnode
		self._tail.link = None
		self._length -= 1
		return item
	
	def __len__(self):
		return self._length
```

###### Когда использовать
Одна из ситуаций, где можно увидеть всю мощь связных списков, проверка списка и удаление из него множества элементов.

#### Хэш таблица
||Поиск|Чтение|Вставка|Удаление|
|------------|:------:|:--------:|:--------:|:-----------:|
|Хэш таблица|O(1)| - |O(1)|O(1)|

>[!info] Ассоциативный массив — абстрактный тип данных, в котором хранятся пары «ключ — значение» с уникальными ключами. В Python представлены словарями.

Коллизии могут снизить эффективность хеш-таблиц, сделав поиск, вставку и удаление равными О(n) в худшем сценарии. И все же хеш-таблицы являются одной из самых эффективных структур для хранения больших наборов данных.

###### Когда использовать

Всякий раз, когда у вас имеется большой объем данных и нужно быстро получить доступ к отдельным элементам, стоит рассмотреть применение хеш-таблицы.

#### Двоичное дерево поиска(BST)
||Поиск|Чтение|Вставка|Удаление|
|------------|:------:|:--------:|:--------:|:-----------:|
|Двоичное дерево поиска(BST)|O(log N)|O(log N)|O(log N)|O(log N)|

>[!info] Двоичное дерево поиска подчиняется следующим правилам:
>- в каждом узле не может быть больше одного «левого» и одного «правого» дочернего элемента;
>- «левые» потомки узла могут содержать только меньшие, чем сам узел, значения. Точно так же «правые» могут содержать только значения, пре­вышающие значение самого узла.

![[bst_.png]]

```
class BinaryTree:
	def __init__(self, value):
		self.key = value
		self.left_child = None
		self.right_child = None
		
	def insert_left(self, value):
		if self.left_child == None:
			self.left_child = BinaryTree(value)
		else:
			bin_tree = BinaryTree(value)
			bin_tree.left_child = self.left_child
			self.left_child = bin_tree
			
	def insert_right(self, value):
		if self.right_child == None:
			self.right_child = BinaryTree(value)
		else:
			bin_tree = BinaryTree(value)
			bin_tree.right_child = self.right_child
			self.right_child = bin_tree

	# обход дерева в ширину
	def breadth_first_search(self, n):
		current = [self]
		next = []
		while current:
			for node in current:
				if node.key == n:
					return True
				if node.left_child:
					next.append(node.left_child)
				if node.right_child:
					next.append(node.right_child)
			current = next
			next = []
		return False
```
```
tree = BinaryTree(1)
tree.insert_left(2)
tree.insert_right(3)
tree.insert_left(4)
tree.left_child.insert_right(6)
tree.insert_right(5)
```

###### Когда использовать

Двоичное дерево поиска - это мощная структура данных на основе узлов, ко­торая позволяет работать с упорядоченными данными и довольно быстро вы­полнять их поиск, вставку и удаление. Оно сложнее, чем связный список, ноработает гораздо эффективнее.

#### Двоичная куча
||Поиск максимума|Извлечение максимума|Вставка|Удаление|
|------------|:------:|:--------:|:--------:|:-----------:|
|Двоичная куча|О(1)|O(log N)|O(log N)|O(log N)|

>[!info] Двоичная куча - это особый вид двоичного дерева. которое предполагает следующие условия:
>- Значение каждого узла должно превышать значение каждого из его по­томков. Это правило определяет основное свойство кучи(корень - самое большое значение).
>- Дерево должно быть полным. Дерево, в котором все уровни заполнены узлами. При этом в последнем уровне могут быть пустые позиции, если справа от них нет никаких узлов.).

![[heap.png]]
Кучи считаются слабо упорядоченными в сравнении с двоичными деревьями поиска. Конечно, некоторый порядок в кучах есть: значения потом­ков не могут превышать значения предков, но этого недостаточно для того, чтобы сделать поиск в них целесообразным.

У кучи есть еще одна особенность: ее корневой узел всегда содержит наибольшее значение (в min-кyчe - наименьшее).
В куче есть так называемый последний узел - крайний правый элемент нижне­го уровня.

```
from heapq import heapify, heappop, heappush

a_list = ['D', 'E', 'L', 'H', 'R', 'T']
heapify(a_list)              # создание min-кучи из списка

heappop(a_list)              #  выталкивание минимального элемента из кучи
heappush(a_list, "Z")        #  вставляет ключ в кучу и повторно балансирует ее
```

###### Когда использовать
- Использование кучи гарантирует, что основные операции - вставка и удаление - будут выполняться очень быстро. 
- Слабая упорядоченность кучи - ее преимущество. Куча достаточно упорядочена, для того чтобы мы всегда могли получить доступ к одному нужному нам элементу. В этом и за­ключается основная ценность этой структуры данных.
- Кучи полезны каждый раз, когда требуется выполнять задачи в соответствии с приоритетом.


#### Граф
>[!info] Граф — это абстрактный тип данных, в котором фрагмент данных соединяется с одним или несколькими другими фрагментами данных. Каждый фрагмент данных в графе называется вершиной или узлом. У вершины есть имя, называемое ключом. У вершины могут быть дополнительные данные, такие как полезная нагрузка. Соединение между вершинами в графе — ребро. Ребра графа могут содержать вес: затраты на перемещение между вершинами.

- ==Ориентированный граф== — тот, в котором у каждого ребра есть связанное с ним направление и между двумя вершинами можно перемещаться только в этом направлении.
- ==Полный граф== — это граф, в котором каждая вершина соединена со всеми другими вершинами
- ==Ациклический граф== — граф, который не содержит цикла

Добавление вершины и ребра в граф, как правило, равно О(1).
Время выполнения поиска, удаления и других алгоритмов в графе зависит от реализации графа и от того, какая структура данных используется для этой реализации: массивы, связные списки, хеш таблицы или что-то еще.

Список смежности
```
class Vertex:
	def __init__(self, key):
		self.key = key
		self.connections = {}
		
	def add_adj(self, vertex, weight=0):
		self.connections[vertex] = weight
		
	def get_connections(self):
		return self.connections.keys()
		
	def get_weight(self, vertex):
		return self.connections[vertex]

class Graph:
	def __init__(self):
		self.vertex_dict = {}
		
	def add_vertex(self, key):
		new_vertex = Vertex(key)
		self.vertex_dict[key] = new_vertex

	def get_vertex(self, key):
		if key in self.vertex_dict:
			return self.vertex_dict[key]
		return None
		
	def add_edge(self, f, t, weight=0):
		if f not in self.vertex_dict:
			self.add_vertex(f)
		if t not in self.vertex_dict:
			self.add_vertex(t)
		self.vertex_dict[f].add_adj(self.vertex_dict[t], weight)
```
```
graph = Graph()
graph.add_vertex("A")
graph.add_vertex("B")
graph.add_vertex("C")
graph.add_edge("A", "B", 1)
graph.add_edge("B", "C", 10)
vertex_a = graph.get_vertex("A")
vertex_b = graph.get_vertex("B")
```

###### Когда использовать
Графы полезны во многих ситуациях. Социальные сети, построение обычных сетей, создание карт, расчёт самого быстрого пути, построение моделей комп. графики и т.д..
