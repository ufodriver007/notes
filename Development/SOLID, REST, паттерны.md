#### SOLID
>[!info] Принципы ООП, устанавливающие практики, помогающие создавать ПО, которое можно обслуживать и расширять. Подход как сделать код менее связанным и более обособленным.

###### S (single responsibility principle) Принцип единственной ответственности
1 класс(сущность) = 1 задача(зона ответственности. Но не упарываться черезмерно)
Улучшается читаемось(из-за декомпозиции), уменьшается связываемость(легче совместно разрабатывать и версионировать)

###### O (open-closed principle) Принцип открытости-закрытости
Сущности должны быть открыты для расширения, но закрыты для изменения
Стараться не изменять, а дополнять сущности(создавать новые)

###### L (Liskov Substitution Principle) Принцип подстановки Барбары Лисков
Наследуемый класс должен ДОПОЛНЯТЬ, а не замещать возможности базового класса. И иметь единообразный интерфейс. 
Т.е. функции, использующие базовый класс должны иметь возможность использовать его подтипы.

###### I (interface segregation principle) Принцип разделения интерфейса
Программные сущности не должны зависеть от методов, которые они не используют
Более предсказуемая работа, код становится менее связанным. 
Т.е. создавайте детализированные интерфейсы, специфичные для конкретного клиента(Класс "Круг" не должен уметь рисовать квадрат).

###### D (dependency inversion principle) Принцип инверсии зависимости
Модули высокого уровня не должны зависеть от модулей более низкого уровня все они
должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали 
должны зависеть от абстракций. 
Т.е. не сылайтесь(и не наследуйтесь) на изменчивые конкретные классы, ссылайтесь на абстрактные.

#### REST
Representational state transfer(Передача состояния представления)
>[!info] Архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Другими словами, REST — это набор правил того, как программисту организовать написание кода серверного приложения, чтобы все системы легко обменивались данными и приложение можно было масштабировать

###### Принципы REST
1) **Независимость от состояния(Statelessness)**
   Сервер не должен запоминать состояние рользователя между запросами. В каждом запросе
   передаётся инфо, идентифицирующая пользователя и все параметры, необходимые для
   выполнения операции.
2) **Многоуровневая архитектура(Layered System)**
   Деление по слоям проще для отладки.
3) **Единый унифицированный программный интерфейс**
   К примеру для получения списка фильмов вы используете URL вида: /videos.com/movies , а для
   получения информации о конкретном фильме ваш URL будет: /videos.com/movies/1
4) **Кэшируемая архитектура(Cacheable)**
   Ответ сервера может быть кэширован на определённый период времени и использоваться
   повторно без новых запросов к серверу
5) **Удобное представление данных**
   В качестве представления данных объекта передаются данные в формате JSON или XML

###### Методы http
- GET       (получение(чтение))
- POST      (создание)
- PUT       (изменение)
- PATCH     (частичное изменение)
- DELETE    (удаление)

#### Паттерны
###### Определение
>[!info] Паттерн проектирования — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.
Паттерны стоят между алгоритмами(чёткими наборами действий) и фреймворками(код с архитектурой,  который можно скопировать себе). Это формальное высокоуровневое описание решения, реализация которого может отличаться в двух разных программах.

Три основные группы паттернов:
1. **Порождающие паттерны** беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.
2.  **Структурные паттерны** показывают различные способы построения связей между объектами.
3.  **Поведенческие паттерны** заботятся об эффективной коммуникации между объектами.

###### Обозначения UML диаграмм
---
**Зависимость**
>[!info] Зависимость — это базовая связь между классами, которая показывает, что один класс скорее всего придётся менять при изменении названия или сигнатуры методов второго.

![[zav.png]]
*Профессор зависит от учебного курса.*
==Класс А могут затронуть изменения в классе B.==

---
**Ассоциация**
>[!info] Ассоциация — это когда один объект взаимодействует с другим. В UML ассоциация обозначается простой стрелкой, которая направлена в сторону взаимодействия. Двухсторонняя ассоциация между объектами тоже вполне допустима.

Ассоциацию можно рассматривать как строгий вариант зависимости, при котором один объект всегда имеет доступ к объекту, с которым он взаимодействует, в то время как при простой зависимости связь может быть не постоянной и не такой явной.

![[ass.png]]
*Профессор взаимодействует со студентом.*
==Объект А знает об объекте B. Класс А зависит от B.==

---
**Агрегация**
>[!info] Агрегация — это специализированная разновидность ассоциации, которая описывает отношения один-ко-многим, многие-ко-многим, часть-целое между несколькими объектами, тогда как ассоциация устанавливает связь только между двумя объектами.

Обычно при агрегации один объект содержит другие, то есть выступает контейнером или коллекцией. Здесь контейнер не управляет жизненным циклом компонентов и компоненты
вполне могут существовать отдельно от контейнера. В UML агрегация обозначается линией со стрелкой на одном конце и пустым ромбом на другом конце. Ромб направлен в сторону контейнера, а стрелка — в сторону включаемого объекта.

![[agg.png]]
*Кафедра содержит профессоров.*
==Объект А знает об объекте B и состоит из него. Класс А зависит от B.==

---
**Композиция**
>[!info] Композиция — это более строгий вариант агрегации, когда один объект состоит из других. Особенность этого отношения заключается в том, что компонент может существовать только как часть контейнера. В UML композиция изображается так же, как и агрегация, но с закрашенным ромбом.

![[comp.png]]
*Университет состоит из кафедр.*
==Объект А знает об объекте B, состоит из него и управляет его жизненным циклом. Класс А зависит от B.==

---

#### Порождающие паттерны
###### Фабричный метод
>[!info] [Фабричный метод](https://refactoring.guru/ru/design-patterns/factory-method) — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов

![[2024-04-03_02-20 1.png]]

>Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор `new`, а через вызов особого _фабричного_ метода. 
>Теперь вы сможете переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта. 
>Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу.

Применимость:  Паттерн можно часто встретить в любом коде, где требуется гибкость при создании продуктов. Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.

```
from __future__ import annotations
from abc import ABC, abstractmethod

class Creator(ABC):
    """
    Класс Создатель объявляет фабричный метод, который должен возвращать объект
    класса Продукт. Подклассы Создателя обычно предоставляют реализацию этого
    метода.
    """

    @abstractmethod
    def factory_method(self):
        """
        Обратите внимание, что Создатель может также обеспечить реализацию
        фабричного метода по умолчанию.
        """
        pass

    def some_operation(self) -> str:
        """
        Также заметьте, что, несмотря на название, основная обязанность
        Создателя не заключается в создании продуктов. Обычно он содержит
        некоторую базовую бизнес-логику, которая основана на объектах Продуктов,
        возвращаемых фабричным методом. Подклассы могут косвенно изменять эту
        бизнес-логику, переопределяя фабричный метод и возвращая из него другой
        тип продукта.
        """

        # Вызываем фабричный метод, чтобы получить объект-продукт.
        product = self.factory_method()

        # Далее, работаем с этим продуктом.
        result = f"Creator: The same creator's code has just worked with {product.operation()}"

        return result

"""
Конкретные Создатели переопределяют фабричный метод для того, чтобы изменить тип
результирующего продукта.
"""

class ConcreteCreator1(Creator):
    """
    Обратите внимание, что сигнатура метода по-прежнему использует тип
    абстрактного продукта, хотя фактически из метода возвращается конкретный
    продукт. Таким образом, Создатель может оставаться независимым от конкретных
    классов продуктов.
    """

    def factory_method(self) -> Product:
        return ConcreteProduct1()

class ConcreteCreator2(Creator):
    def factory_method(self) -> Product:
        return ConcreteProduct2()

class Product(ABC):
    """
    Интерфейс Продукта объявляет операции, которые должны выполнять все
    конкретные продукты.
    """

    @abstractmethod
    def operation(self) -> str:
        pass

"""
Конкретные Продукты предоставляют различные реализации интерфейса Продукта.
"""

class ConcreteProduct1(Product):
    def operation(self) -> str:
        return "{Result of the ConcreteProduct1}"

class ConcreteProduct2(Product):
    def operation(self) -> str:
        return "{Result of the ConcreteProduct2}"

def client_code(creator: Creator) -> None:
    """
    Клиентский код работает с экземпляром конкретного создателя, хотя и через
    его базовый интерфейс. Пока клиент продолжает работать с создателем через
    базовый интерфейс, вы можете передать ему любой подкласс создателя.
    """

    print(f"Client: I'm not aware of the creator's class, but it still works.\n"
          f"{creator.some_operation()}", end="")

if __name__ == "__main__":
    print("App: Launched with the ConcreteCreator1.")
    client_code(ConcreteCreator1())
    print("\n")

    print("App: Launched with the ConcreteCreator2.")
    client_code(ConcreteCreator2())
```

Простой пример
```
class Engine:  
    def __init__(self, x, y):  
        self.x = x  
        self.y = y  
  
    def __str__(self):  
        return f'x: {self.x}, y: {self.y}'  
  
    @staticmethod  
    def new_car_engine(x, y):  
        return Engine(x + x , y + y)  
  
    @staticmethod  
    def new_ship_engine(x, y):  
        return Engine(x * x , y * y)  
  
  
my_ship_engine = Engine.new_ship_engine(3, 3)  
print(my_ship_engine)                          # x: 9, y: 9
my_car_engine = Engine.new_car_engine(3, 3)  
print(my_car_engine)                           # x: 6, y: 6
```

Простое объяснение
>[!info] Чтобы создавать разные объекты в одном классе при этом не городя огород в инициализаторе. Есть несколько методов, каждый из которых создаёт экземпляр класса **по особенному**

Дополнение:
- [Абстрактные классы в Python](https://www.codecamp.ru/blog/python-abstract-base-classes-abc/)
- [Видео про фабричный метод](https://www.youtube.com/watch?v=FONWO-xdqYo)

###### Абстрактная фабрика
>[!info] [Абстрактная фабрика](https://refactoring.guru/ru/design-patterns/abstract-factory/python/example#lang-features)  — это порождающий паттерн проектирования, который решает проблему создания целых семейств связанных продуктов, без указания конкретных классов продуктов.
>