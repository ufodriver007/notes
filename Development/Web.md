>[!info] http запрос -> nginx(проксирующий сервер) -> application server(Python-server(Gunicorn, uWSGI, Uvicorn))

CDN - Content Delivery Network. Сеть серверов дублирующих контент. Для лучшей географической доступности и балансировки трафика.

Docker - легковесная виртуалка для контейнеризации.

Уровни протоколов:
1. **Прикладной**
    Уровень приложений, форматов данных.(FTP, SMB, HTTP, HTTPS, SSH, DNS)

2. **Транспортный**
    Пакеты данных.(TCP, UDP)

3. **Межсетевой**
    Регламентирует и стандартизирует взаимодействие сетей.(IP)

4. **Канальный**
    Самый низкий. Формирование данных на физическом уровне.

==IP. Internet Protocol.== Отвечает за доставку сообщений по адресу.
==URL(Uniform Resource Locator)== протокол + домен https://www.google.com
==URI(Uniform Resource Identifier)== протокол + домен + адрес ресурса + параметры + возможно якорь https://www.google.com/search?q=python#ch1

#### HTTP
Порт по умолчанию 80
http2 передаёт уже бинарные данные, а не текст.
http3 работает не через TCP, а через QUIC(QUIC — экспериментальный сетевой протокол транспортного уровня).

#### HTTPS
Порт по умолчанию 443
Это шифрованный http.

###### Исследуем запросы через telnet
```
telnet google.com 80
HEAD / HTTP/1.0                  # метод head, адрес /, версия спецификации http 1.0      
HOST: google.com   
```

Начиная с http версии 1.1 появились виртуальные хосты. Поэтому в запросе должен быть заголовок
```
HOST: ...
```

#### Коды ответов(статус коды)
[Подробное описание](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)

|Коды|Описание|
|-----|-----------|
|`1xx`|информационный
|`2xx`|успешное выполнение
|`3xx`|перенаправление
|`4xx`|ошибка клиента
|`5xx`|ошибка сервера

Например
```
200           Ок
201           Created
301           Moved Permanently
400           Bad request
401           Unauthorized
403           Forbidden
404           Page not found
500           Internal server error
```

#### Методы http
Некоторые методы:
- HEAD (получить только заголовки)
- GET ( получение ресурса)     
- POST (создание ресурса)        
- PUT (обновление ресурса)
- PATCH (частичное обновление ресурса)
- DELETE (удаление ресурса)
- OPTIONS (описание параметров соединения)

Передача данных зависит от Content-Type. Form-Data или в теле запроса.Текст, json, xml и тд

#### Cookie
Хранит состояние. Текстовая инфо, сохранённая в браузере. У куки есть время жизни.
Можно установить домен или конкретный адрес. Можно изолировать куки от JS(Http Only).
Можно подписать куки криптографической подписью. Общий механизм подписи таков:
 1) Берём все значения куки, сортируем в алфавитном порядке, переводим в строку(;) и обрезаем
   пробелы
 2) Добавляем к этой строке соль и хэшируем
 Если кука была украдена и изменена, то подпись будет другой, т.к. вор не знает значение соли

>[!info] Соль - добавление какого-то определённого значения сервером к паролю перед хэшированием.

>[!info] Аутентификация - это проверка подлинности(проверка пары логин-пароль).

>[!info] Авторизация - это проверка права доступа на определённое действие.

#### Как информация попадает на сервер
1. Как часть URI
2. GET/query параметры
3. Тело запроса POST, PUT и т.д.
4. Cookies

>[!info] Радужные таблицы - это таблицы с набором часто используемых паролей и хэшей от них.

>[!info] Сокет - это программный интерфейс для обеспечения информационного обмена между процессами
Веб сокет позволяет установить и поддерживать постоянно открытое соединение. Например для того, чтобы пушить сообщения из чата. Он состоит из пары IP-порт

Классический Django-стек состоит из 4 базовых элементов: Web-сервера, WSGI-сервера, самого Django и СУБД.

==nginx== - проксирующий сервер(WEB server). Обрабатывает ВСЕ запросы, работает быстро, блокирует ненужные (передаёт все запросы по портам 80 и 443 передаёт дальше)

==gunicorn== - python WSGI(Web Server Gateway Interface) сервер(Application server). Переводит запросы от nginx в формат, который понимает django и обеспечивает выполнение кода при необходимости. Основная его задача — это работа в режиме демона и поддержка постоянной работы Web-приложений.

Порядок работы:
- Веб-сервер, в нашем случае Nginx, принимает и обрабатывает HTTP-запрос браузера, затем передаёт его в Application-сервер — Gunicorn.
- Gunicorn получает данные от Nginx, разбирает их и исходя из своей конфигурации по протоколу WSGI передаёт их в Django.
- Django обрабатывает полученные данные и возвращает результат работы обратно в Gunicorn, а он в свою очередь отдаёт результат в Nginx, который возвращает клиенту готовую HTML-страницу.

![[yT153avGzxA.jpg]]

## SPA
>[!info] **Single Page Application** — это архитектурный подход, при котором приложение загружает единственный HTML-документ и динамически обновляет его содержимое по мере взаимодействия пользователя, без перезагрузки страницы. Все переходы между “страницами” реализуются средствами клиентского роутинга, а данные запрашиваются через API. Это позволяет добиться плавного пользовательского опыта: интерфейс остаётся на месте, обновляется только нужный фрагмент.

|Категория|Плюсы|Минусы|
|---|---|---|
|**Производительность**|Быстрая навигация между страницами после первого загрузки|Долгое первое отображение (FCP), особенно на больших приложениях|
|**SEO**|Можно использовать для интерактивных страниц с динамическим контентом|SEO хуже по умолчанию, контент генерируется на клиенте|
|**UX**|Плавная навигация, мгновенные переходы между страницами|При медленном интернете пользователи ждут полной загрузки JS|
|**Архитектура**|Проще строить сложные интерактивные интерфейсы|Начальная загрузка может быть тяжёлой|
|**Кэширование**|Легко кэшировать API-запросы и данные|HTML кэшировать сложнее, контент динамический|
|**Обновление данных**|Отлично для часто обновляющихся данных без перезагрузки страницы|Нужно вручную управлять синхронизацией с сервером|

## SSR
>[!info] ** Server Side Rendering** предполагает, что HTML генерируется на сервере либо полностью, либо частично. Это позволяет отдать пользователю уже готовую разметку ещё до загрузки JavaScript. Такой подход отлично работает для контентных страниц, лендингов и e-commerce.

|Категория|Плюсы|Минусы|
|---|---|---|
|**Производительность**|Быстрое первое отображение страницы (FCP)|Больше нагрузки на сервер, особенно при высоком трафике|
|**SEO**|Контент сразу доступен поисковым роботам|Требуется более сложная настройка для динамического контента|
|**UX**|Пользователи с медленным интернетом видят страницу быстрее|Интерактивность ограничена без дополнительного JS|
|**Архитектура**|Можно отдавать готовый HTML клиенту|Более сложная архитектура и поддержка|
|**Кэширование**|Можно эффективно кэшировать готовый HTML|Кэширование динамического контента сложнее, чем в SPA|
|**Обновление данных**|Подходит для страниц с редко меняющимся контентом|Для часто обновляемого контента требуется дополнительная логика обновления|

#### Что выбрать: практический ориентир

|Цель   | Рекомендуемый подход  |
|---|---|
|Высокая интерактивность, сложные интерфейсы|SPA|
|Быстрый старт, SEO, Маркетинговые страницы|SSR/SSG|
|Требуется и то, и другое|Универсальный фреймворк (Next.js, Nuxt и др.)|