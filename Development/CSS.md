![[CSS3_logo.png|300]]

[Справочник](https://developer.mozilla.org/ru/docs/Web/CSS)
[Основы, справочник, уроки](https://html5book.ru/)

#### Адаптивная вёрстка
>[!info] Адаптивность — это широкий подход к веб-дизайну, который сосредотачивается на пригодности для различных интерфейсов, а не ограничивается десктопным форматом.

**Существует два основных подхода:**
- responsive web design (RWD) или отзывчивый дизайн;
- adaptive web design (AWD) или адаптивный дизайн.

###### Отзывчивый дизайн (RWD)
Заполняет контентом все доступное окно браузера и динамически реагирует на изменение размера экрана. На всех устройствах работает один и тот же макет по одному и тому же URL-адресу, расширяясь или сужаясь, как вода или воздушный шар.

Отзывчивый веб-дизайн базируется на трех принципах:

- гибкий макет на основе сетки (flexible, grid-based layout);
- гибкие изображения (flexible images);
- медиа-запросы (CSS3 media queries).

Основная идея гибкой сетки — не использовать фиксированные значения в пикселях. Вместо этого верстальщик опирается на относительные единицы измерения — например, проценты — и подстраивает отступы, минимальные и максимальные размеры блоков так, чтобы осмысленно и аккуратно заполнять все доступное пространство.

Гибкие изображения необходимы, чтобы подобрать оптимальный вариант для конкретного устройства в зависимости от размера, ориентации и типа дисплея. Для этого используются атрибуты srcset и sizes: первый дает возможность указать пути ко всем вариациям изображения и размеры в пикселях, второй — задавать критерии выбора того или иного изображения через медиа-запросы.

С помощью атрибутов можно подсказать браузеру, какую версию картинки загружать: для узкого экрана — облегченную версию для смартфонов, для широкого телевизора — картинку в тройном размере.

Медиа-запросы дают возможность перестроить страницу под необходимую ширину экрана. Например, спрятать ненужный сайдбар и перестроить колонки одну под другой на мобильных или изменить кегль и интерлиньяж на широких экранах.

###### Адаптивный дизайн  (AWD)
Базируется на нескольких фиксированных макетах для самых популярных размеров экрана. Все варианты сайта открываются по одному и тому же URL.

Обычно отрисовывают шесть макетов в соответствии с самой популярной шириной экрана:
- 320 px;
- 480 px;
- 760 px;
- 960 px;
- 1200 px;
- 1600 px.

Когда сайт определяет пространство, он выбирает макет, наиболее подходящий для экрана и отображает его пользователю. При изменении размера окна браузера переход между макетами происходит скачкообразно, а не плавно.

>[!info] На сегодня чаще используется *отзывчивый дизайн (RWD)*, так как создание и поддержка единственного универсального макета занимает меньше времени и стоит дешевле. Адаптивный дизайн оправдан в сложных проектах, заточенных под определенные устройства: например, во время разработки сайта онлайн-банкинга, основная масса пользователей которого посещают сайт с последних моделей iPhone.

**Современное размещение и выравнивание элементов происходит с помощью двух подходов [[CSS#Flexbox Layout]] или `Grid`**
*Существуют также устаревшие подходы с помощью `float` и `table`.*

#### Подключение css стилей
###### Внешние
Подключение внешнего файла со стилями - внутрь `<head>` добавляем `<link rel="stylesheet" href="static/style.css">`
###### Встроенные
`<style></style>` встраивание css стилей

#### Выпадающее меню
```css
.drop:hover .nav-list {
    display: block;
    position: absolute;
    background-color: black;
}
```

При наведении курсора на кнопку, список ссылок становится блочным(чтобы вся площадь элемента была кликабельна), абсолютное позиционирование(выдёргиваем из потока) и даём чёрный цвет фона.

#### Селекторы
##### По типу
###### id
```css
#main { ... }
```

###### class
```css
.main { ... }
```

###### tag
```css
p { ... }
```

###### атрибут
все инпуты с типом `submit`
```css
input[type="submit"] { ... }
```

все элементы с атрибутом `id`
```css
[id] { ... }
```

##### Комбинации и группирование
###### Перечисление (группировка)
класс `main`,  класс `baby`
```css
.main,
.baby { ... }
```

###### И
обращение по классу И тэгу(вес 11)
```css
div.main { ... }
```

###### дочерний комбинатор(прямые потомки)
обращение ко всем img с классом container (`>` дочерний комбинатор(прямые потомки))
```css
.container > img { ... }
```

###### дочерний комбинатор(все потомки)
обращение ко всем span внутри p (дочерний комбинатор(все потомки))
```css
p span { ... }
```

###### следующий элемент
следующий `p` после элемента с классом `my_form`
```css
.my_form + p { ... }
```

###### соседи
Все элементы `h2`, которые находятся после элемента `h1` внутри одного родителя
```css
h1 ~ h2 { ... }
```

###### все элементы
обращение ко всем элементам
```css
* { ... }
```

##### Псевдоклассы
элемент в фокусе
```css
input:focus { ... }
```

первый потомок
```css
li:first-child { ... }
```

последний потомок
```css
li:last-child { ... }
```

n-потомок
```css
li:nth-child(2) { ... }
```

n-потомок (только чётные)
```css
li:nth-child(even) { ... }
```

n-потомок (каждый третий)
```css
li:nth-child(3n) { ... }
```

Первый из одноуровневых p
```css
p:first-of-type { font-weight: 700; }
```

Второй  из одноуровневых p
```css
p:nth-of-type(2) { color: green; }
```

Последний  из одноуровневых p
```css
p:last-of-type { text-decoration: underline; }
```

Кроме (все параграфы, кроме параграфов с классом `main`)
```css
p:not(.main) { color: green; }
```

##### Псевдоэлементы
###### after
Создаёт пседоэлемент после всех ссылок
```css
a::after {
	color: red;
	content: " ! "
}
```

###### before
Создаёт пседоэлемент до всех ссылок
```css
a::before {
	color: red;
	content: " ! "
}
```

###### selection
Стилизация выделения
```css
*::selection {
	color: red;
	background-color: yellow;
}
```

#### Вес(приоритетность правил)
|Вес|Описание|
|-----|------------|
|1|по тегу
|10|по классу, атрибуту или псевдоклассу
|100|по id
|1000|инлайновый стиль(в самом теге)
|бесконечно большой вес|!important (например `border-style: solid !important;`)

#### Комментарий
```
/* comment */ 
```

#### Медиа запрос
[Справочник](https://developer.mozilla.org/ru/docs/Web/CSS/@media)
>[!tip] Удобно писать эти запросы в конце файла стилей

>[!info] Обычно используют `max-width` когда сайт в основном десктопный, а `min-width` когда сайт в первую очередь под мобильные.

медиа запрос. стили, которые будут применяться с шириной экрана от 1 до 900px
```css
@media (max-width: 900px){  

}
```

#### Свойства
>[!info] Если у свойства неколько числовых параметров, то:
>- Если 2: верх/низ и право/лево
>- Если 3: верх и право/лево и низ
>- Если 4: верх, право, низ, лево

|Свойство|Описание|
|-------|------------|
|`width: 500px;`|ширина(блочные элементы)
|`height: 50px;`|высота(блочные элементы)
|`max-width: 700px;`|максимальная ширина(блочные элементы)
|`min-width: 375px;`|минимальная ширина(блочные элементы)
|`font-size: 24px;`|размер шрифта
|`font-style: italic;`|стиль шрифта
|`font-weight: bold;`|жирный шрифт
|`background-color:green;`|задний фон
|`margin: 30px auto;`|внешний отступ (центрировано авто отступ слева/справа)
|`padding: 5px;`|внутренний отступ
|`padding-inline: 10px;`|внутр. отступ справа и слева
|`display: block;`|блочный элемент
|`display: inline;`|строчный элемент
|`display: inline-block;`|строчный элемент, но реагирующий на настройки высоты и ширины
|`display: grid;`|сетка
|`grid-template-columns: 1fr 1fr 1fr;`|настройка сетки на 3 колонки
|`grid-template-rows: repeat(4, 300px)`|высота 4х строк сетки - 300px
|`grid-column: 3/11;`|занять колонки с 3ей по 10(не включая 11)
|`grid-row: 3/11;`|занять строки с 3ей по 10(не включая 11)
|`text-align: center;`|выравнивание текста по центру элемента
|`display: flex;`|делает контейнер flex
|`flex-direction: row;`|выравнивание содержимого flex-контейнера в сточку
|`flex-direction: column;`|выравнивание содержимого flex-контейнера колонкой
|`align-items: center;`|выравнивание элементов flex-контейнера, если он колонкой
|`justify-content: space-between;`|свободное пространство блока разделяется между элементами
|`border-style: solid;`|рамка
|`border-width: 0.5px;`|толщина рамки
|`float: right;`|расположение в блочном контейнере справа с обтеканием
|`list-style: none;`|убрать точки элементов списка
|`position: relative;`|относительное позиционирование. документ в потоке, можно сдвигать его с помощью `top` и `left`
|`position: absolute;`|абсолютное позиционирование. элемент выпадает из потока
|`position: fixed;`|зафиксировать элемент в окне. при скролле он будет на одном месте
|`position: sticky;`|липнет к краям экрана. двигается только в пределах своего контейнера

#### Еденицы измерения
Шрифт по умолчанию = 16px, соответственно, величина 1em и 1rem = 16px
100vh это 100% от высоты вьюпорта 

>[!warning] Vw - это ширина вьюпорта. 100vw - это 100% от ширины вьюпорта. Однако многие браузеры прибавляют к этому ещё и вертикальную полосу прокрутки. Из-за этого ширина становится больше 100% и появляется горизонтальная прокрутка.

- ==em== еденица, наследуемая от родителя
- ==rem== еденица, наследуемая от главного родителя
- ==Vh== размер в процентах от высоты вьюпорта
- ==Vw== размер в процентах от ширины вьюпорта
- ==vmin== размер в процентах от меньшего из 2х значений(высоты и ширины вьюпорта)
- ==vmax== размер в процентах от большего из 2х значений(высоты и ширины вьюпорта)

#### Кнопка с картинкой
```html
<button class="image-button"></button>
```
```css
.image-button {
  width: 100px;
  height: 50px;
  border: none;
  background-image: url('path/to/image.jpg');
  background-size: cover;
}
```

#### Шрифты
>[!tip] Для адаптивной вёрстки удобно устанавливать размер шрифта в `vw` или `vmin`/`vmax`

```css
font-size: 4vw;
```

###### Локально
[Справочник](https://developer.mozilla.org/ru/docs/Web/CSS/@font-face)
```css
@font-face {
  font-family: "Open Sans";
  src:
    url("/fonts/OpenSans-Regular-webfont.woff2") format("woff2"),
    url("/fonts/OpenSans-Regular-webfont.woff") format("woff");
}
```

###### Через CDN
Идём в [Google Fonts](https://fonts.google.com/?query=roboto). Выбираем шрифт, тыкаем `get embeded code` и получаем html-код подключения файлов из CDN гугла.

#### Иконки
С помощью сайта [cdnjs.com](https://cdnjs.com/) Можно подключить практически любую библиотеку через CDN. Ищем там `fontawesome`, получаем ссылку, подключаем у себя(в шапке до css).
Далее идём на [fontawesome.com](https://fontawesome.com/search) и ищем нужную бесплатную иконку. Получаем её код и подключаем её себе.

#### Переменные
Инициализация
```css
:root {
  --bg-color: #f5f5f5;
  --text-color: #6c757d;
  --accent-color: #ffd333;
  --contrast-color: #3d464d;
}
```
Использование
```css
body {
  background-color: var(--bg-color);
  color: var(--text-color);
}
```

#### Математические функции
###### Calc
```css
width: calc(100% - 20px);
```

###### Min
```css
width: min(20%, 100px);
```

###### Max
```css
font-size: max(4vmax, 48px);
```

###### Clamp
>[!info] Задаёт значение в диапазоне между указанными нижней и верхней границами. Функция принимает три аргумента: минимальное значение, предпочитаемое значение и максимально допустимое.

Задаём рамки для ширины. Желательно 80%, но минимум 200px, а максимум 600px
```css
width: clamp(200px, 80%, 600px);
```

#### Анимация
###### Простейшая анимация
Все свойства
```css
.my_button {
	background-color: blue;
	transition: all 300ms;
}

.my_button:hover {
	background-color: white;
}
```

Определённое свойство
```css
.my_button {
	background-color: blue;
	transition: background-color 300ms;
}

.my_button:hover {
	background-color: white;
}
```

Задержка в 1 секунду перед анимацией. Сама анимация 300мс
```css
transition: all 300ms 1s;
```

###### Transition timing functions
[Справочник функций](https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function)
`easy-out` вначале ускоряется и плавно заканчивает
```css
.my_button {
	background-color: blue;
	transition: background-color 300ms;
}

.my_button:hover {
	background-color: white;
	transition-timing-function: ease-out;
}
```

Анимация по кривой Безье
```css
transition-timing-function: cubic-bezier(0.1, 0.7, 1, 0.1);
```
[Наглядное представление кривых Безье](https://cubic-bezier.com/)

###### Transform
[Справочник](https://developer.mozilla.org/en-US/docs/Web/CSS/transform)
Вращать на 180 градусов
```css
transform: rotate(180deg);
```

Вращение как будто это в 3D
```css
transform: rotate3d(0, 1, 0, 360deg);
```

Перемещение вправо
```css
transform: translateX(2em);
```

###### Animation
```css
.my_button {
	background-color: blue;
	animation: my-move 2s ease forwards;
	animation-delay: 1s;
	animation-iteration-count: 5;
}

@keyframes my-move {
	100% {
		transform: rotate(180deg);
	}
}
```
`forwards` заставляет анимацию остаться в конечном состоянии

#### Flexbox Layout
>[!info] Этот подход следует выбрать когда нужно собрать **небольшие блоки** или когда **блоки расположены в одном направлении**.

```html
<div class="container">
	<div class="item">1</div>
	<div class="item">2</div>
	<div class="item">3</div>
	<div class="item">4</div>
	<div class="item">5</div>
</div>
```
Как только мы ставим свойство у `container` `display: flex;`, этот контейнер становится flex-контейнером, а его непосредственные потомки получают специальные свойства

###### flex-direction
У `flex` есть 2 оси: основная и вспомогательная
Изменяются они с помощью `flex-direction: row;` или `flex-direction: column;`

flex-direction: row
![[2025-02-07_05-21.png]]

flex-direction: column
![[2025-02-07_05-21_1.png]]

Есть также значения `flex-direction: row-reverse`  и `flex-direction: column-reverse`

###### flex-wrap
Если выставить у `item` ширину побольше, они займут всю доступную ширину
`flex-wrap` позволяет переносить `items` на следуюшую строку, если они не влезают (изменяет вспомогательную ось)
```css
flex-wrap: wrap;
```

Если всем элементам добавить `box-sizing: border-box` и у `item` поставить ширину ровно треть (`width: calc(100% / 3);`), то получится ровно три колонки
![[2025-02-07_05-32.png]]

>[!info] Есть сокращённое свойство `flex-flow`. Оно заключает в себе оба основных атрибута: `flex-direction` и `flex-wrap`. Например запись `flex-flow: row nowrap;` аналогична записи
```css
flex-direction: row;
flex-wrap: nowrap;
```

###### order
У каждого `item` есть до умолчанию свойство `order: 0;`
Так мы можем менять порядок элементов
```css
.item4 {
	order: 1;
}
```
![[2025-02-07_05-41.png]]

###### Justify-content
Выравнивание контента во флекс боксе **по основной оси**

|свойство|описание|
|---|---|
|`justify-content: flex-start`|выровнять flex элементы по началу контейнера|
|`justify-content: flex-end`|выровнять flex элементы по концу контейнера|
|`justify-content: center`|выровнять flex элементы по центру контейнера|
|`justify-content: space-between;`|свободное пространство блока разделяется между элементами|

###### Align-items
Выравнивание контента во флекс боксе **по вспомогательной оси** относительно каждой строчки

|свойство|описание|
|---|---|
|`align-items: flex-start`|выровнять flex элементы по началу контейнера|
|`align-items: flex-end`|выровнять flex элементы по концу контейнера|
|`align-items: center`|выровнять flex элементы по центру контейнера|
|`align-items: baseline;`|выравнивает текст по базовой линии|

###### Align-content
Выравнивание **всего** контента во флекс боксе **по вспомогательной оси**

|свойство|описание|
|---|---|
|`align-content: flex-start`|выровнять flex элементы по началу контейнера|
|`align-content: flex-end`|выровнять flex элементы по концу контейнера|
|`align-content: center`|выровнять flex элементы по центру контейнера|
|`align-content: baseline;`|выравнивает текст по базовой линии|

>[!tip] Свойства легко запомнить так: `justify` выравнивает по основной оси, `align` по вспомогательной. `content` выравнивает всё в общем, `items` выравнивает относительно каждой строчки

###### Align-self
Позиционирует отдельный `item` по **по вспомогательной оси**
```css
align-self: center;
```

###### Flex
>[!info] Позволяет задавать пропорции

Свойство `flex: 1;` у всех `item` означает, что `item` займет 1 часть из всех в строке(колонке)
![[2025-02-07_06-28.png]]

Свойство `flex: 1;` у одного `item`(при том что все остальные без него) означает, что он занимает всё свободное пространство, а остальные просто прибиваются в сторону
![[2025-02-07_06-30.png]]

>[!info] Если у какого-то `item` с большим числом `flex` не будет хватать вьюпорта для всей его ширины, он будет сжиматься. В этом отличие от жёсткой привязки к пиксельным размерам.

###### Flex-basis, Flex-grow и Flex-shrink
![[2025-02-07_06-38.png]]
`flex-basis: 300px;` означает базовую ширину(если `flex-direction: row`) или высоту(если `flex-direction: column`) контента у `item`
`flex-grow: 1;` означает часть(пропорцию) заполнения свободного пространства в строке(колонке)

![[2025-02-07_06-45.png]]
`flex-shrink: 5` означает часть(пропорцию) сжатия `item` относительно других `item`. Начинает работать после того, как вьюпорт сжал итемы в строчке(колонке) до их *базовых величин*.

>[!info] Короткая запись `flex: 1 2 300px;` означает `flex-grow: 1;`, `flex-shrink: 2;`, `flex-basis: 300px;`

###### Gap
В контейнере добавляем свойство
```css
row-gap: 20px;         # зазаор между строками
column-gap: 30px;      # зазаор между колонками
gap: 10px 20px;        # короткая запись(вертикальный отступ и гориз. отступ)
```

###### Отодвигаем элемент от всех остальных
Трюк с `margin: auto;`
Допустим мы хотим отделить первый элемент от всех остальных
![[2025-02-07_07-31.png]]

Просто ставим первому элементу
```
margin-right: auto;
```

###### Пример стилей вёрстки
Вёрстка в 4 колонки с зазорами между элементами
```css
.container {
	display: flex;
	flex-wrap: wrap;
	gap: 20px;
}

.item {
	flex 0 1 calc(100% / 4 - 20px * 3 / 4)
}
```
Пояснение для вычисляемого значения `flex-basis`(3-e значение атрибута `flex):
- ширина вьюпорта 100% делим на количество колонок(4)
- и отнимаем ширину зазора(20) умноженную на кол-во промежутков(3) и делённую на кол-во колонок(4)

#### БЭМ (методология наименования и структурирования кода)
>[!info] БЭМ (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки. Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно использовать существующий код, избегая «Copy-Paste».

Соблюдение правил методологии ускоряет процесс разработки:
- упрощает код и облегчает рефакторинг;
- избавляет от необходимости комментировать код, поскольку назначение CSS-селекторов становится очевидным по названиям;
- позволяет использовать одни и те же фрагменты кода многократно, в том числе на одном DOM-узле;
- предотвращает взаимное влияние компонентов друг на друга.

###### Блок
>[!info] Блок — логически и функционально независимый компонент страницы: меню, боковая панель, карусель, шапка сайта и так далее. Блок включает в себя шаблоны (Pug, Handlebars) и CSS-стили, скрипты JavaScript, документацию в формате XML или Markdown, другие необходимые для реализации технологии.

![[bem-1-4393378.png|500]]
*Шапка сайта инкапсулирует навигационное меню, логотип, поиск и авторизацию*

Независимость блоков позволяет свободно перемещать их в пределах страницы и всего проекта. Составные части блока, например формы авторизации и поиска, можно поменять местами: они будут корректно работать и сохранят внешний вид. Внесение изменений в CSS- или JavaScript-скрипты форм не потребуется.

Благодаря верстке по БЭМ на страницах можно размещать сколько угодно экземпляров одного и того же блока. Блоки можно вкладывать друг в друга. Допустима любая вложенность блоков.

![[bem-3-2026663 1.png|500]]
Методология упрощает многократное использование компонентов

###### Элемент
>[!info] Элемент — неотделимая составная часть блока.

Особенности элементов:
- они не существуют и не используются вне блока;
- принадлежат только одному блоку;
- могут вкладываться друг в друга.
![[bem-2-4269636.png|500]]
Это необязательные компоненты: небольшие блоки могут обходиться без вложенных элементов. Методология не устанавливает жестких правил в отношении того, когда разработчику следует использовать блок, а когда — элемент. Блоки, как правило, нужно создавать в том случае, если фрагмент кода может использоваться самостоятельно. *Зависимым фрагментам кода (элементам) необходима родительская сущность — блок.*

Рекомендации БЭМ-верстки касаются смысла и структуры наименования элементов:

1. Название элемента должно характеризовать его смысл, роль — item («пункт меню»), link («ссылка»).
2. Структура имени элемента должна соответствовать схеме **имя-блока__имя-элемента** **—** ==имя элемента отделяется двойным подчеркиванием.==

###### Модификатор
>[!info] Модификатор — это сущность, которая определяет внешний вид, состояние и поведение элемента или блока. Один и тот же блок, например меню, будет выглядеть по-разному в зависимости от применяемых модификаторов.

![[bem-4-1382617.png|500]]
*Внешний вид верхнего и нижнего меню заметно отличается.*

Модификаторы делятся на два типа:

3. **Булевые.** Применяют, когда факт наличия модификатора важнее, чем его значение. Например, если элемент имеет модификатор disabled («отключен»), значение по умолчанию равно true. Структура имени при использовании булевого модификатора выглядит так: **имя-блока__имя-элемента_имя-модификатора.**
4. **Ключ-значение.** Используют в тех случаях, когда значение модификатора важно. Например, если применяется блок с определенной темой оформления: **search-form_theme_forest.** Структура наименования модификатора элемента соответствует схеме: **имя-блока__имя-элемента_имя-модификатора_значение-модификатора.**

==имя модификатора отделяют от имени блока или элемента одним подчеркиванием==
название модификатора должно характеризовать:
- внешний вид блока или элемента;
- состояние компонента;
- поведение.



#### Bootstrap
>[!info] Это фреймворк для создания сайтов и веб-приложений с открытым исходным кодом. Включает в себя HTML- и CSS-шаблоны оформления для типографики, веб-форм, кнопок, меток, блоков навигации и прочих компонентов веб-интерфейса, включая JavaScript-расширения.

[Сайт Bootstrap](https://getbootstrap.com/docs/5.3/getting-started/introduction/)
[Документация на русском](https://bootstrap-4.ru/docs/5.3/getting-started/introduction/)
Docs->Download->CDN копируем пути css и js

|Имя файла|Описание|
|------|------|
|`bootstrap.js`|Сама библиотека Bootstrap|
|`bootstrap.min.js`|Сжатая версия Bootstrap(без пробелов, некоторых точек с запятой и т.д.)|
|`bootstrap.bundle.js`|Bootstrap + Popper(плагин всплывающих подсказок)|
|`bootstrap.bundle.min.js`|Сжатая версия Bootstrap + Popper(плагин всплывающих подсказок)|
|`bootstrap.esm.js`| Версия Bootstrap, построенная как ESM (позволяет использовать Bootstrap в качестве модуля в браузере)|

5. В шапке указываем тег
```html
<meta name="viewport" content="width=device-width, initial-scale=1">
```
Этот тег определяет, как нужно настроить параметры окна браузера для конкретного устройства, особенно это актуально для мобильного телефона.

6. Подключаем CSS и JS. Можно указать путь к CDN, а можно скачать в свой проект.
CSS
```
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
```
>[!warning] Свои стили подлючаем ПОСЛЕ подключения стилей bootstrap

JS(В конец тега body)
```
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
```

###### Прижатие footer вниз
**В Bootstrap**
```html
<div class="container-fluid">
    <div class="row">
        <footer class="footer d-flex fixed-bottom bg-black text-white">
            FOOTER
        </footer>
    </div>
</div>
```

**Обычный вариант**
[Компоновка flex на странице](https://tproger.ru/translations/how-css-flexbox-works)
HTML
```html
<div class="wrapper">
    <header class="header">Header</header>
    <main class="main">Content</main>
    <footer class="footer">Footer</footer>
</div>
```

CSS
```css
html, body {
  height: 100%;
}

.wrapper {
  min-height: 100%;
  display: flex;
  flex-direction: column;
}

main.main {
  flex: 1 1 auto;
}
```
Пояснение для `flex: 1 1 auto;`.  Это включает в себя несколько параметров:
7. `flex-grow` определяет как много свободного пространства во flex-контейнере должно быть назначено текущему элементу. Т.е. 1 означает всё.
8. `flex-shrink` фактор сжатия flex-элемента. Т.е. 1 означает макс.
9. `flex-basis` задаёт базовый размер флекс элемента по основной оси(т.е. по `column`)

###### Сетка
В Bootstrap 12 колонок. Для начала добавьте в шапку 
```html
<meta name="viewport" content="width=device-width, initial-scale=1" />
```
>[!info] Breakpoint - это ключевое значение ширины `viewport`

[Доступные `breakpoints`](https://getbootstrap.com/docs/5.3/layout/breakpoints/#available-breakpoints). 

|Breakpoint|Class infix|Dimensions|
|---|---|---|
|Extra small|_None_|<576px|
|Small|`sm`|≥576px|
|Medium|`md`|≥768px|
|Large|`lg`|≥992px|
|Extra large|`xl`|≥1200px|
|Extra extra large|`xxl`|≥1400px|

Сетка состоит из:
- оберточных контейнеров (элементов с классом container, container-fluid, или
container-{breakpoint));
- рядов или строк (элементов с классом row);
- адаптивных колонок или блоков, имеющих один или несколько классов col.

Типичный пример сетки
```html
<div class="container">
    <div class="row>
        <div class="col">1</div>
        <div class="col">2</div>
        <div class="col">3</div>
    </div>
</div>
```

###### Контейнеры
>[!info] Контейнер - это элемент сетки Bootstrap, с которого обычно начинается создание макета страницы или ее части. Другими словами, это ба­зовый элемент, в котором необходимо размещать все другие элементы сетки (ряды и адаптивные блоки). Его основная цель - это установить шаблону ширину и выровнять его по центру страницы

Bootstrap поставляется с двумя базовыми контейнерами:
10. адаптивно фиксированный контейнер (класс container)- устанавливает максималь­ную ширину (max-width) для каждой контрольной точки;
*Для адаптивно фиксированного контейнера можно указать контрольную точку (container-{breakpoint)), при этом будет установлена максимальная ширина (width: 100%) до указанной контрольной точки.*
11. адаптивно подвижный («резиновый») контейнер (класс container-fluid), который устанавливает максимальную ширину (width: 100%) во всех контрольных точках.
```html
<div class="container-fluid"> ...</div>
```
12. контейнер с указанием брейкпоинта

###### Ряды(row)
Элемент сетки страницы, который выступает в роли контейнера для адаптивных блоков (колонок).
```html
<div class="row"> ... </div>
```

###### Адаптивные блоки (соl)
Адаптивные блоки располагаются только внутри ряда.
Это блоки, ширина которых на разных контрольных точках (breakpoint) может быть различной
Примеры

|Колонка|Описание|
|---|---|
|`class="col-lg-5"`|Начиная с брейкпоита `lg`(≥992px) ширина блока будет равна 5 из 12 колонок (т.е. 41.6%)|
|`class="col-xl-3"`|Начиная с брейкпоита `xl`(≥1200px) ширина блока будет равна 3 из 12 колонок (т.е. 25%)
|`class="col-xxl-6"`|Начиная с брейкпоита `xxl`(≥1400px) ширина блока будет равна 6 из 12 колонок (т.е. 50%)

**Вертикальное выравнивание блоков**

|Класс|Описание|
|---|---|
|`align-items-start`|выравнивание относительно начала ряда (по верху ряда);
|`align-items-center`|по центру ряда;
|`align-items-end`|относительно конца ряда (по низу ряда).

**Горизонтальное выравнивание блоков**

|Класс|Описание|
|---|---|
|`justify-content-start`|по левому краю
|`justify-content-center`|по центру
|`justify-content-end`|по правому краю
|`justify-content-around`|равномерно, с учетом пространства перед первым и послед­ним адаптивными блоками
|`justify-content-between`|равномерно, с одинаковым пространством между адаптив­ными блоками

###### Использование стилей, путём добавления классов
[Категория **Utilities**](https://getbootstrap.com/docs/5.3/utilities/background/)

|Класс|Описание|
|---|---|
|`py-1`|Padding по оси Y 1px|
|`ms-2`|Margin Start 2px|
|`me-5`|Margin End 5 px|
|`d-none`|Display: none|
|`d-flex`|Display: flex|
|`justify-content-end`|Выравнивание по правому краю|
|`sticky-top`|Всегда отображать блок вверху
|`sticky-bottom`|Всегда отображать блок внизу

и т.д.

Пример элемента, который занимает 6 колонок (из 12), а если ширина viewport ≥768px (md), то 4 колонки(из 12).
```html
<div class="col-6 col-md-4>

</div>
```