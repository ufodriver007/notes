
![[Regex.webp]]

```
import re
```

Пример регулярного выражения в Python
```
re.search(pattern, stroka, flags)
```

Третий необязательный аргумент - флаги, например:
```
flags=re.IGNORECASE для регистронезависимого поиска
```

|Флаги|Описание|
|------|-----------|
|`re.IGNORECASE`|для регистронезависимого поиска
|`re.MULTILINE`|спецсимволы ^ и $ будут совпадать не с началом и концом всего текста, а с началом и концом строк.
|`re.DOTALL`|Точка теперь будет соответствовать любому символу. Если флаг не используется - точка соответствует любому символу, кроме символа новой строки.

для нескольких флагов нужно их сложить:
```
flags=re.IGNORECASE + re.MULTILINE
```

#### Методы, возвращающие match-объект

|Метод|Описание|
|------|-----------|
|`re.search(pattern, stroka)`|ищет ПЕРВОЕ соответствие в любом месте строки, если нет соответствия, то None
|`re.match(pattern, stroka)`|ищет ПЕРВОЕ соответствие с НАЧАЛА строки, если нет соответствия, то None
|`re.fullmatch(pattern, stroka)`|проверяет ВСЮ строку на соответствие регулярному выражению, если нет, то None
|`re.finditer(pattern, stroka)`|ищет ВСЕ совпадения, возвращает итератор со всеми match-объектами(можно пройти в цикле)

###### Методы match-бъекта
|Метод|Описание|
|------|-----------|
|`.group()`|Возвращает группу по её номеру(нулевая - всё что захватило рег.выраж.)
|`.groups()`|Возвращает кортеж со всеми группами
|`.groupdict()`|Словарь именованных групп(имя группы:значение)
|`.start()`|Передаём группу, получаем индекс вхождения начала
|`.end()`|Передаём группу, получаем индекс вхождения конца

#### Методы, возвращающие результат

|Метод|Описание|
|------|-----------|
|`re.findall(pattern, stroka)`|ищет все совпадения во всей строке, возвращает список совпадений(только группы)
|`re.split(pattern, stroka, 1)`|разделяет строку по заданному разделителю, заданное кол-во раз
|`re.sub(pattern, replace, string, count=0, flags=0)`|заменяет pattern на replace, возвращает изменённую строку
|`re.subn(pattern, replace, string, count=0, flags=0)`|заменяет pattern на replace, возвращает кортеж(изменённую строку и кол-во замен)
|`re.escape(stroka)`|экранирует символы

>[!info] `re.sub` может принимать функцию в качестве замены(а также и лямбда функции):

```
def func(x):
    print(x)
    return '1'
re.sub(r'asdf', func, stroka)              # находит в строке asdf и передаёт match-объект в 
                                           #  функцию, которая возвращ. '1' как замену
```

Находим стоящие рядом цифры в строке(от 1 до 3 вместе)
```
re.findall('0|2{1,3}|3{1,3}|4{1,3}|5{1,3}|6{1,3}|7{1,3}|8{1,3}|9{1,3}',str)
```

Замена рядом стоящих букв на одну
```
re.sub(r'(\w)\1+', r'\1', str)
```

Перестановка
```
re.sub(r'\b(\w+)\b(\w+)\b', r'\2\1', str)
```

Замена паттерна(1ая группа-любой символ, 2ая группа-одна большая буква) на другой паттерн(подчёркивание между 1 и 2 группой)
```
re.sub(r'(.)([A-Z])', r'\1_\2', str(string))
```

#### Метасимволы
|Символ|Возможный эквивалент|Соответствие|
|-------|-------------------|-----------------|
|`\d`|`[0-9]`|Цифровой символ|
|`\D`|`[^0-9]`|Нецифровой символ|
|`\s`|`[ \f\n\r\t\v]`|Пробельный символ|
|`\S`|`[^ \f\n\r\t\v]`|Непробельный символ|
|`\w`|`[A-Za-z0-9_]`|Буквенный или цифровой символ или знак подчёркивания; буквы ограничены латиницей. Пример: Выражение вида \w+ будет находить и выделять отдельные слова|
|`\W`|`[^A-Za-z0-9_]`|Любой символ, кроме буквенного или цифрового символа или знака подчёркивания|

#### Позиция внутри строки

|Символ|Обозначение|
|-------|-----------|
|`^`|Начало текста
|`$`|Конец текста
|`\b`|Граница слова (Промежуток между \w\W и \W\w)
|`\B`|Не граница слова (Промежуток между \w\w и \W\W)
|`\G`|Предыдущий успешный поиск           aaa aaa (поиск остановился на 4-й позиции — там, где не нашлось a)
|`ко[тд]`|любое значение из скобок("кот" или "код")
|`ко[^тд]`|любое значение кроме значения из скобок(не "кот" или не "код")

#### Квантификаторы
|Представление|Число повторений|Эквивалент|Пример|Соответствие|
|------------|---------------|-------------|----------|------------|
|`?`|Ноль или одно|`{0,1}`|`colou?r`|color, colour|
|`*`|Ноль или более|`{0,}`|`colou*r`|color, colour, colouur и т. д.|
|`+`|Одно или более|`{1,}`|`colou+r`|colour, colouur и т. д. (но не color)|

#### Особые символы
|Символ|Описание|
|-------|------------|
|`[]`|Набор символов или диапазон|
|`/`|Символ перехода(escape-символ) экранирование|
|`[^]`|Символ отрицания в наборе символов|
|`.`|Любой символ кроме новой строки|
|<code>\|</code>|Или|

Примеры
```
.*                       любое количество символов
[0-9]{11}                любая цифра 11 раз
```

#### Ленивая квантификация
>[!info] Жадные квантификаторы - это те, которые найдут максимально возможное количество совпадений. Ленивые - минимум. Все квантификаторы по умолчанию жадные. Чтобы сделать из жадного квантификатора ленивый, добавляем ? т.е. получаются `{2,7}? *? +? ??`

#### Группировка
>[!info] Можно именовать группы.

```
(?P<test>\d{2})     Именованная группа test с шаблоном \d{2}
(?P=test)           Ссылка на группу test(найдёт тот же текст, который захватила группа test)
\1                  Обращение к группе 1
```

Выражения.
```
(?#comment)           комментарий
(?:something)         группировка без обратной связи. используется только для группировки и её
                       результат в дальнейшем не потребуется. такой группе не назначается номер.
```

#### Просмотр вперёд и назад
###### Позитивный просмотр вперёд
```
[a-z]{4}(?= )         слово из 4х букв, после которого пробел(который не включён в ит
```
###### Негатитивный просмотр вперёд
```
[a-z]{4}(?! )         последовательность из 4х букв, после которой НЕТ пробела
```
###### Позитивный просмотр назад
```
(?<= )[a-z]{4}        последовательность из 4х букв, перед которой пробел
```
###### Негативный просмотр назад
```
(?<! )[a-z]{4}        последовательность из 4х букв, перед которой НЕТ пробела
```
>[!info] При просмотре назад(позитивном и негативном) шаблон должен быть фиксированной длины, т.е. `\d+` будет ошибкой

#### Пример валидации email
```
re.match(r'^.+@(\w+\.){0,2}[a-z]{2,6}$', email, re.IGNORECASE)
```

Пояснение:
- `r` - это raw string
- С начала(`^`) и до конца(`$`) строки(т.е вся строка)
- Любой символ(`.`) в количестве от одного(`+`)
- Символ собаки (`@`)
- Буквенный или цифровой символ или подчёркивание(`\w`) в количестве от одного(`+`). Точка (`\.`). Могут встречаться от 0 до 2 раз `{0,2}`
- Латиница от `a` до `z` `([a-z])`. В количестве от 2 до 6 символов (`{2,6}`)

#### Пример валидции пароля
```
(?=.*[0-9])(?=.*[!@#$%^&*])(?=.*[a-z])(?=.*[A-Z])[0-9a-zA-Z!@#$%^&*]{6,}
```

Пояснение:
- `(?=.*[0-9]) `- строка содержит хотя бы одно число;
- `(?=.*[!@#$%^&*])` - строка содержит хотя бы один спецсимвол;
- `(?=.*[a-z])` - строка содержит хотя бы одну латинскую букву в нижнем регистре;
- `(?=.*[A-Z])` - строка содержит хотя бы одну латинскую букву в верхнем регистре;
- `[0-9a-zA-Z!@#$%^&*]{6,}` - строка состоит не менее, чем из 6 вышеупомянутых символов.

#### Catastrophic backtracking
>[!info] Если к группе применён квантификатор и внутри этой группы используется ещё один квантификатор или условие или, то регулярное выражение может быть неконтролируемым.

Примеры таких выражений:
```
(?:a+)+
([a-zA-Z_]+)*
(?:a|aa)+
(a|a?)+
```

Что делать если в выражении есть catastrophic backtracking?
Есть следующие способы решить эту проблему:
- Постараться переписать регулярное выражение (если это возможно)
- Перед использованием выражения проверять входные данные (например, не принимать слишком большой текст)
- Использовать специальные средства из модуля `re`
- Контролировать использование регулярного выражения (например, останавливать поиск, если он идёт слишком долго)

