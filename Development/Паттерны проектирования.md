
###### Определение

**Паттерн проектирования** — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.

Паттерны стоят между алгоритмами(чёткими наборами действий) и фреймворками(код с архитектурой, который можно скопировать себе). Это формальное высокоуровневое описание решения, реализация которого может отличаться в двух разных программах.

Три основные группы паттернов:

1. **Порождающие паттерны** беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.
2. **Структурные паттерны** показывают различные способы построения связей между объектами.
3. **Поведенческие паттерны** заботятся об эффективной коммуникации между объектами.

Ссылки почитать
https://github.com/faif/python-patterns
https://refactoring.guru/ru/design-patterns/python


###### Обозначения UML диаграмм
---
**Зависимость**
>[!info] Зависимость — это базовая связь между классами, которая показывает, что один класс скорее всего придётся менять при изменении названия или сигнатуры методов второго.

![[zav.png|300]]
*Профессор зависит от учебного курса.*
==Класс А могут затронуть изменения в классе B.==

---
**Ассоциация**
>[!info] Ассоциация — это когда один объект взаимодействует с другим. В UML ассоциация обозначается простой стрелкой, которая направлена в сторону взаимодействия. Двухсторонняя ассоциация между объектами тоже вполне допустима.

Ассоциацию можно рассматривать как строгий вариант зависимости, при котором один объект всегда имеет доступ к объекту, с которым он взаимодействует, в то время как при простой зависимости связь может быть не постоянной и не такой явной.

![[ass.png|300]]
*Профессор взаимодействует со студентом.*
==Объект А знает об объекте B. Класс А зависит от B.==

---
**Агрегация**
>[!info] Агрегация — это специализированная разновидность ассоциации, которая описывает отношения один-ко-многим, многие-ко-многим, часть-целое между несколькими объектами, тогда как ассоциация устанавливает связь только между двумя объектами.

Обычно при агрегации один объект содержит другие, то есть выступает контейнером или коллекцией. Здесь контейнер не управляет жизненным циклом компонентов и компоненты
вполне могут существовать отдельно от контейнера. В UML агрегация обозначается линией со стрелкой на одном конце и пустым ромбом на другом конце. Ромб направлен в сторону контейнера, а стрелка — в сторону включаемого объекта.

![[agg.png|300]]
*Кафедра содержит профессоров.*
==Объект А знает об объекте B и состоит из него. Класс А зависит от B.==

---
**Композиция**
>[!info] Композиция — это более строгий вариант агрегации, когда один объект состоит из других. Особенность этого отношения заключается в том, что компонент может существовать только как часть контейнера. В UML композиция изображается так же, как и агрегация, но с закрашенным ромбом.

![[comp.png|300]]
*Университет состоит из кафедр.*
==Объект А знает об объекте B, состоит из него и управляет его жизненным циклом. Класс А зависит от B.==

---
#### Порождающие паттерны
###### Фабричный метод
>[!info] [Фабричный метод](https://refactoring.guru/ru/design-patterns/factory-method) — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов

![[2024-04-03_02-20 1.png]]

>Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор `new`, а через вызов особого _фабричного_ метода. 
>Теперь вы сможете переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта. 
>Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу.

Применимость:  Паттерн можно часто встретить в любом коде, где требуется гибкость при создании продуктов. Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.

```python
from __future__ import annotations
from abc import ABC, abstractmethod

class Creator(ABC):
    """
    Класс Создатель объявляет фабричный метод, который должен возвращать объект
    класса Продукт. Подклассы Создателя обычно предоставляют реализацию этого
    метода.
    """

    @abstractmethod
    def factory_method(self):
        """
        Обратите внимание, что Создатель может также обеспечить реализацию
        фабричного метода по умолчанию.
        """
        pass

    def some_operation(self) -> str:
        """
        Также заметьте, что, несмотря на название, основная обязанность
        Создателя не заключается в создании продуктов. Обычно он содержит
        некоторую базовую бизнес-логику, которая основана на объектах Продуктов,
        возвращаемых фабричным методом. Подклассы могут косвенно изменять эту
        бизнес-логику, переопределяя фабричный метод и возвращая из него другой
        тип продукта.
        """

        # Вызываем фабричный метод, чтобы получить объект-продукт.
        product = self.factory_method()

        # Далее, работаем с этим продуктом.
        result = f"Creator: The same creator's code has just worked with {product.operation()}"

        return result

"""
Конкретные Создатели переопределяют фабричный метод для того, чтобы изменить тип
результирующего продукта.
"""

class ConcreteCreator1(Creator):
    """
    Обратите внимание, что сигнатура метода по-прежнему использует тип
    абстрактного продукта, хотя фактически из метода возвращается конкретный
    продукт. Таким образом, Создатель может оставаться независимым от конкретных
    классов продуктов.
    """

    def factory_method(self) -> Product:
        return ConcreteProduct1()

class ConcreteCreator2(Creator):
    def factory_method(self) -> Product:
        return ConcreteProduct2()

class Product(ABC):
    """
    Интерфейс Продукта объявляет операции, которые должны выполнять все
    конкретные продукты.
    """

    @abstractmethod
    def operation(self) -> str:
        pass

"""
Конкретные Продукты предоставляют различные реализации интерфейса Продукта.
"""

class ConcreteProduct1(Product):
    def operation(self) -> str:
        return "{Result of the ConcreteProduct1}"

class ConcreteProduct2(Product):
    def operation(self) -> str:
        return "{Result of the ConcreteProduct2}"

def client_code(creator: Creator) -> None:
    """
    Клиентский код работает с экземпляром конкретного создателя, хотя и через
    его базовый интерфейс. Пока клиент продолжает работать с создателем через
    базовый интерфейс, вы можете передать ему любой подкласс создателя.
    """

    print(f"Client: I'm not aware of the creator's class, but it still works.\n"
          f"{creator.some_operation()}", end="")

if __name__ == "__main__":
    print("App: Launched with the ConcreteCreator1.")
    client_code(ConcreteCreator1())
    print("\n")

    print("App: Launched with the ConcreteCreator2.")
    client_code(ConcreteCreator2())
```

Простой пример
```python
class Engine:  
    def __init__(self, x, y):  
        self.x = x  
        self.y = y  
  
    def __str__(self):  
        return f'x: {self.x}, y: {self.y}'  
  
    @staticmethod  
    def new_car_engine(x, y):  
        return Engine(x + x , y + y)  
  
    @staticmethod  
    def new_ship_engine(x, y):  
        return Engine(x * x , y * y)  
  
  
my_ship_engine = Engine.new_ship_engine(3, 3)  
print(my_ship_engine)                          # x: 9, y: 9
my_car_engine = Engine.new_car_engine(3, 3)  
print(my_car_engine)                           # x: 6, y: 6
```

Простое объяснение
>[!info] Чтобы создавать разные объекты в одном классе при этом не городя огород в инициализаторе. Есть несколько методов, каждый из которых создаёт экземпляр класса **по особенному**

Дополнение:
- [Абстрактные классы в Python](https://www.codecamp.ru/blog/python-abstract-base-classes-abc/)
- [Видео про фабричный метод](https://www.youtube.com/watch?v=FONWO-xdqYo)

###### Абстрактная фабрика
>[!info] [Абстрактная фабрика](https://refactoring.guru/ru/design-patterns/abstract-factory/python/example#lang-features)  — это порождающий паттерн проектирования, который решает проблему создания целых семейств связанных продуктов, без указания конкретных классов продуктов.
>