#### SOLID
>[!info] Принципы ООП, устанавливающие практики, помогающие создавать ПО, которое можно обслуживать и расширять. Подход как сделать код менее связанным и более обособленным.

###### S (single responsibility principle) Принцип единственной ответственности
1 класс(сущность) = 1 задача(зона ответственности. Но не упарываться черезмерно)
Улучшается читаемось(из-за декомпозиции), уменьшается связываемость(легче совместно разрабатывать и версионировать)

###### O (open-closed principle) Принцип открытости-закрытости
Сущности должны быть открыты для расширения, но закрыты для изменения
Стараться не изменять, а дополнять сущности(создавать новые)

###### L (Liskov Substitution Principle) Принцип подстановки Барбары Лисков
Наследуемый класс должен ДОПОЛНЯТЬ, а не замещать возможности базового класса. И иметь единообразный интерфейс. 
Т.е. функции, использующие базовый класс должны иметь возможность использовать его подтипы.

###### I (interface segregation principle) Принцип разделения интерфейса
Программные сущности не должны зависеть от методов, которые они не используют
Более предсказуемая работа, код становится менее связанным. 
Т.е. создавайте детализированные интерфейсы, специфичные для конкретного клиента(Класс "Круг" не должен уметь рисовать квадрат).

###### D (dependency inversion principle) Принцип инверсии зависимости
Модули высокого уровня не должны зависеть от модулей более низкого уровня все они
должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали 
должны зависеть от абстракций. 
Т.е. не сылайтесь(и не наследуйтесь) на изменчивые конкретные классы, ссылайтесь на абстрактные.

#### REST
Representational state transfer(Передача состояния представления)
>[!info] Архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Другими словами, REST — это набор правил того, как программисту организовать написание кода серверного приложения, чтобы все системы легко обменивались данными и приложение можно было масштабировать

###### Принципы REST
1) **Независимость от состояния(Statelessness)**
   Сервер не должен запоминать состояние рользователя между запросами. В каждом запросе
   передаётся инфо, идентифицирующая пользователя и все параметры, необходимые для
   выполнения операции.
2) **Многоуровневая архитектура(Layered System)**
   Деление по слоям проще для отладки.
3) **Единый унифицированный программный интерфейс**
   К примеру для получения списка фильмов вы используете URL вида: /videos.com/movies , а для
   получения информации о конкретном фильме ваш URL будет: /videos.com/movies/1
4) **Кэшируемая архитектура(Cacheable)**
   Ответ сервера может быть кэширован на определённый период времени и использоваться
   повторно без новых запросов к серверу
5) **Удобное представление данных**
   В качестве представления данных объекта передаются данные в формате JSON или XML

###### Методы http
- GET       (получение(чтение))
- POST      (создание)
- PUT       (изменение)
- PATCH     (частичное изменение)
- DELETE    (удаление)

#### Паттерны
###### Определение
>[!info] Паттерн проектирования — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.
Паттерны стоят между алгоритмами(чёткими наборами действий) и фреймворками(код с архитектурой,  который можно скопировать себе). Это формальное высокоуровневое описание решения, реализация которого может отличаться в двух разных программах.

Три основные группы паттернов:
1. **Порождающие паттерны** беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.
2.  **Структурные паттерны** показывают различные способы построения связей между объектами.
3.  **Поведенческие паттерны** заботятся об эффективной коммуникации между объектами.

###### Обозначения UML диаграмм
---
**Зависимость**
>[!info] Зависимость — это базовая связь между классами, которая показывает, что один класс скорее всего придётся менять при изменении названия или сигнатуры методов второго.

![[zav.png]]
*Профессор зависит от учебного курса.*
==Класс А могут затронуть изменения в классе B.==

---
**Ассоциация**
>[!info] Ассоциация — это когда один объект взаимодействует с другим. В UML ассоциация обозначается простой стрелкой, которая направлена в сторону взаимодействия. Двухсторонняя ассоциация между объектами тоже вполне допустима.

Ассоциацию можно рассматривать как строгий вариант зависимости, при котором один объект всегда имеет доступ к объекту, с которым он взаимодействует, в то время как при простой зависимости связь может быть не постоянной и не такой явной.

![[ass.png]]
*Профессор взаимодействует со студентом.*
==Объект А знает об объекте B. Класс А зависит от B.==

---
**Агрегация**
>[!info] Агрегация — это специализированная разновидность ассоциации, которая описывает отношения один-ко-многим, многие-ко-многим, часть-целое между несколькими объектами, тогда как ассоциация устанавливает связь только между двумя объектами.

Обычно при агрегации один объект содержит другие, то есть выступает контейнером или коллекцией. Здесь контейнер не управляет жизненным циклом компонентов и компоненты
вполне могут существовать отдельно от контейнера. В UML агрегация обозначается линией со стрелкой на одном конце и пустым ромбом на другом конце. Ромб направлен в сторону контейнера, а стрелка — в сторону включаемого объекта.

![[agg.png]]
*Кафедра содержит профессоров.*
==Объект А знает об объекте B и состоит из него. Класс А зависит от B.==

---
**Композиция**
>[!info] Композиция — это более строгий вариант агрегации, когда один объект состоит из других. Особенность этого отношения заключается в том, что компонент может существовать только как часть контейнера. В UML композиция изображается так же, как и агрегация, но с закрашенным ромбом.

![[comp.png]]
*Университет состоит из кафедр.*
==Объект А знает об объекте B, состоит из него и управляет его жизненным циклом. Класс А зависит от B.==

---

