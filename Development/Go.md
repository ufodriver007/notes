![[Go_Logo_Blue.svg|300]]

>[!info] Go - компилируемый статически типизированный язык программирования от компании Google. Автоматиическая сборка мусора, параллелизм, поддержка многоядерности, кроссплатформенность.

[Сайт разработчиков](https://go.dev/)
[Документация](https://go.dev/doc/)
[GO Playground](https://go.dev/play/)

[Установка](https://go.dev/doc/install)

Проверка версии
```go
go version
```

## Hello, world
Создадим файл `hello.go`
```go
package main                      // пакет точка входа в приложение

import "fmt"

func main() {                     // функция тока входа в приложение
    fmt.Println("Hello, world!")
}
```

Запуск компилятора и выполнение программы
```bash
go run hello.go
```

Сделать билд
```bash
go build hello.go
```

## Пакеты
>[!info] Весь код в языке Go организуется в **пакеты**. **Пакет** представляют удобную организацию разделения кода на отдельные части или модули. Физически **пакет** — это просто каталог/папка, которая содержит несколько файлов с исходным кодом на Go. Импортируя пакет, мы можем использовать функциональность его файлов многократно в различных программах.

Виды пакетов:
- Точка входа в приложение (`main`)
- Стандартный пакет библиотеки Go (напр. `fmt`)
- Наши собственные пакеты
- Внешние пакеты

## Модули
>[!info] Модуль в языке Go представляет коллекцию пакетов, который имеет встроенное версионирование и который можно опубликовать для использования в других проектах.

**Инициализация модуля**. Чтобы превратить проект (каталог) в модуль, в корневом каталоге проекта надо выполнить команду
```bash
go mod init [имя_модуля]
```

Появится файл `go.mod`. Этот файл объявляет путь к модулю, версию Go, используемую в проекте, и список всех зависимостей с их минимальными требуемыми версиями.
Если наш проект будет использовать Git и располагаться где-то во репозитории, то обычно в качестве имени модуля используется URL репозитория. Например
```bash
go mod init github.com/your-username/your-project
```

## Импорты
Можно так
```go
import "fmt"
import "math"
```

Но лучшей практикой будет использование скобок для группировки
```go
import (
	"fmt"
	"math"
)
```

При использовании имени в пакете оно должно быть с **большой** буквы
```go
fmt.Println(math.Pi)  // Правильно
fmt.Println(math.pi)  // undefined: math.pi
```

## Типы данных
```go
bool

string

int  int8  int16  int32  int64             // целые положительные и отрицательные
uint uint8 uint16 uint32 uint64 uintptr    // целые положительные
byte // alias for uint8

rune // alias for int32
     // represents a Unicode code point

float32 float64

complex64 complex128
```

## Переменные
>[!info] В Go используют CamelCase, т.е. `userHeight`

Переменным, объявленным без явного начального значения, присваивается _нулевое значение_
- `0`для числовых типов,
- `false`для булевого типа и
- `""`(пустая строка) для строк.

Объявление нескольких переменных с **одним** типом
```go
var c, python, java bool
```

Объявление с инициализацией. Если присутствует инициализатор, тип можно опустить
```go
var i, j int = 1, 2
var c, python, java = true, false, "no!"
```

Внутри функции можно использовать оператор `:=` для быстрого объявления с неявным типом
```go
func main() {
	k := 3
}
```

## Константы
```go
const Truth = true
```

В одном определении можно объявить разу несколько констант
```go
const (
    pi float64 = 3.1415
    e float64 = 2.7182
)
```

Инициализировать константу значением переменной нельзя
```go
var m int = 7
const k = m   // ОШИБКА
```

## Преобразование типов
Выражение `T(v)` конвертирует значение `v` в тип `T`
```go
var i int = 42
var f float64 = float64(i)
```

## Функции
Типы в аргументах идут **после** имени переменной
```go
func add(x int, y int) int {  // возвращаемый тип int
	return x + y
}
```

Если у всех аргументов один тип, можно его ставить только последней переменной
```go
func add(x, y int) int {  // возвращаемый тип int
	return x + y
}
```

Функции могут возвращать любое количество аргументов
```go
func swap(x, y string) (string, string) {  // возвращаемый тип (string, string)
	return y, x
}
```

Возвращаемое значение может быть именованным
```go
// Это называется "голый" возврат. Ухудшает читаемость в длинных функциях
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}
```

#### Defer
Оператор defer позволяет выполнить определенную функцию в конце окружающей функции. Обычно с помощью оператора **defer** выполняется операции очистки, например, закрытие файлов, или какие-то действия, которые должны быть выполнены в самом конце.
```go
package main
import "fmt"

func main() {
    defer finish()
    fmt.Println("Program has been started")
    fmt.Println("Program is working")
}

func finish(){
    fmt.Println("Program has been finished")
}
```


## Циклы
Go имеет только цикл **FOR**
```go
func main() {
    for i := 0; i < 10; i++ {
        fmt.Println(i)
    }
}
```

Инициализатор и пост-условие *необязательны*. Так получается аналог `while`
```go
func main() {
	sum := 1
	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}
```

Бесконечный цикл
```go
for {
}
```

## Логические операции
```go
a == b         // Равно
a < b
a <= b
a > b
a => b
a != b         // НЕ равно
!a             // Инвертирует значение
a && b         // И
a || b         // ИЛИ
```

## Условные конструкции
#### If
```go
if x < 0 {
	fmt.Println(x)
}
```

#### If-else
```go 
a := 6
b := 7

if a < b {
    fmt.Println("a меньше b")
} else {
    fmt.Println("a больше b")
}
```

```go
a := 6

if a < b {
    fmt.Println("a меньше b")
} else if a == b {
    fmt.Println("a равно b")
} else if a > b {
    fmt.Println("a больше b")
}
```

#### Switch
```go
a := 8
switch(a) {
    case 9:
        fmt.Println("a = 9")
    case 8:
        fmt.Println("a = 8")
    case 7:
        fmt.Println("a = 7")
}
```

Также конструкция switch может содержать *необязательных* блок `default`, который выполняется, если ни один из операторов case не содержит нужного значения
```go
a := 8
switch(a) {
    case 9:
        fmt.Println("a = 9")
    case 8:
        fmt.Println("a = 8")
    case 7:
        fmt.Println("a = 7")
    default:
        fmt.Println("значение переменной a не определено")
}
```

Также можно указывать после оператора case сразу несколько значений
```go
a := 8
switch(a) {
    case 9, 8, 7:
        fmt.Println("a = 9 или 8 или 7")
    default:
        fmt.Println("значение переменной a не определено")
}
```

## Ввод пользователя
```go
var yourVariable float64

fmt.Scan(&yourVariable)  // указатель на переменную
```

## Строки
Многострочный вывод
```go
myString = `d32asd32as
dasdasd45
sad32
343`
```

Для возврата функций `Print` существуют их аналоги `Sprint`, `Sprintf`, `Sprintln`
```go
result := fmt.Sprintf("Ваш индекс массы тела: %.2f \n", IMT)
```

#### Форматирование
Вывод с форматированием
```go
var yourVariable float64 = 122.7745634208234
fmt.Printf("Ваше значение: %v", yourVariable)
```

[Описание подстановочных значений](https://pkg.go.dev/fmt#section-documentation)
Значение
```go
fmt.Printf("Now you have %g problems", math.Sqrt(7))
```

Тип
```go
fmt.Printf("Now you have %T problems", math.Sqrt(7))
```
