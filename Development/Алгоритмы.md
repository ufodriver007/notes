>[!info] Нотация «O большое» — это математическое обозначение, описывающее, как по мере роста n возрастают требования алгоритма к времени и объему памяти (Время выполнения алгоритма описывается РОСТОМ количества операций.)

==Временная сложность== — это максимальное количество элеметарных шагов, проделываемых алгоритмом для решения задачи. ОЦЕНКА СЛОЖНОСТИ ОПРЕДЕЛЯЕТСЯ ПО ХУДШЕМУ СЦЕНАРИЮ

==Пространственная сложность== —  зависимость количества занимаемой памяти от размера входных данных.

#### Категории сложности алгоритмов(от самого медленного к быстрому)
(n - кол-во ОПЕРАЦИЙ)

|Сложность|Описание|
|-----------|------------|
|O(N!)|факториальная
|O(2ⁿ)|экспоненциальная
|O(N²)|квадоатичная
|O(N * log N)|линейно-логарифмическая
|O(N)|линейная
|O(log N)|логарифмическая
|O(1)|константная

#### Логарифмы
>[!info] Логарифмы здесь (log) всегда указываются по основанию 2

>[!info] ЛОГАРИФМ - степень(b), в которую надо возвести основание(n), чтобы получить аргумент(x)
$$logₙx = b$$
**n** *основание *
**x** *аргумент*

## Алгоритмы поиска
#### Линейный поиск(простой перебор)
>[!info] Время выполнения - линейное O(n)

В Python для этого  можно использовать оператор in
Следует рассматривать вариант использования, когда данные не отсортированы

#### Бинарный поиск. На вход получает отсортированную последовательность.
>[!info] Время выполнения -логарифмическое O(Log n)

Делим пополам(в середине - опорный элемент). Смотрим опорный элемент меньше или больше, ищем дальше в соответствующей части. До тех пор, пока опорный элемент не станет равен искомому значению

Максимальное число проверок не более *log x*(по основанию 2, здесь и далее.)
-Определяются две переменных. Верхняя и нижняя граница. Каждый раз вычисляется среднее значение 
 (оно округляется в меньшую сторону).Если это среднее значение слишком мало, то нижняя граница 
 обновляется. Если СЗ слишком велико, то обновляется верхняя граница.

```
def binary_search(list, item):
    low = 0
    high = len(list) - 1

    while low <= high:               # пока эта часть не сократится до одного элемента...
        mid = (low + high)           # ...проверяем средний элемент
        guess = list[mid]
        if guess == item:            # если значение найдено
           return mid
        if guess > item:             # много
            high = mid - 1
        else:                        # мало
            low = mid + 1
    return None                      # значение не существует
```
Используют, когда данные отсортированы(и в особенности, когда их много)
В реальных проектах нужно пользоваться функцией bisect_left из модуля bisect
```
from bisect import bisect_left

def binary_search(arr, target):
    index = bisect_left(arr, target)
    if <= len(arr) and arr[index] == target:     # нужно проверить индекс, поскольку bisect_left
        return True                              #   может вернуть индекс, выходящий за
                                                 #   пределы последов.
    return False
```

## Поиск в графах
#### Поиск в глубину (DFS, Depth Fiгst Search),
>[!info] O(V + E) вершины + рёбра

1. Начинаем со случайной вершины графа.
2. Добавляем текущую вершину в хеш-таблицу, чтобы отметить ее как посещенную.
3. Перебираем соседей текущей вершины.
4. Игнорируем смежные вершины, которые уже были посещены.
5. Если смежная вершина не бьutа посещена, рекурсивно выполняем поиск в глубину, начиная с нее.

#### Поиск в ширину (BFS, Breadth-First Search)
>[!info] O(V + E) вершины + рёбра

Алгоритм для решения задачи поиска кратчайшего пути называется поиском в ширину.
Для создания двухсторонней очереди в Python используется deque()

```
from collections import deque
search_queue = deque()                     # создание новой очереди
search_queue += graph['you']               # все соседи добавляются в очередь поиска(1ый уровень)
searched = []                              # массив для отслеживания уже проверенных.
                                           #  предохраняет от бесконечного цикла

while search_queue:                        # пока очередь не пуста...
   person = search_queue.popleft()         # из очереди извлекается первый человек
   if not person in searched:              # проверяется только в случае, если не был проверен ранее
      if person_is_seller(person):         # проверяем, является ли этот чел продавццом манго
         return True                       # да, это продавец
      else:
         search_queue += graph[person]     # нет, не является. Все друзья этого чела добавляются в очередь поиска
         searched.append(person)           # человек помечается как уже проверенный
return False                               # если дошло сюда, значит в очереди нет продавца манго
```

#### Алгоритм Дейкстры
>[!info] Сложность алгоритма(E - рёбра, V - вершины).
>1.  Если вершины хранятся в простом массиве и для поиска минимума используется алгоритм линейного поиска, временная сложность алгоритма Дейкстры составляет **O(V² + E)**
   2. Если же используется очередь с приоритетами, реализованная на основе двоичной кучи (или на основе set), то мы получаем **O(E log V)**
   3. Если же очередь с приоритетами была реализована на основе кучи Фибоначчи, получается наилучшая оценка сложности **O(V log V + E)**

Поиск кратчайшего пути во взвешенных графах. Алгоритм работает только с ненаправленными ациклическими графами
Этот алгоритм работает только с положительными весами рёбер. Для графов с отрицательными весами необходим алгоритм Беллмана-Форда
1. Найти узел с наименьшей стоимостью (то есть узел, до которого можно
    добраться за минимальное время).
2. Проверить, существует ли более дешевый путь к соседям этого узла,
    и если существует, обновить их стоимости.
3. Повторять, пока это не будет сделано для всех узлов графа.
4. Вычислить итоговый путь

```
nоdе = find_lowest_cost_node (costs)             # Найти узел с наименьшей стоимостью среди
                                                 #  необработанных

while node is not None :                         # Если обработаны все узлы, цикл while завершён
   cost = costs[node]
   neighbors = graph[node]
   for n in neighbors.keys():                    # Перебрать всех соседей текущего узла
      new_cost = cost + neighbors[n] 
      if costs[n] > new_cost:                    # Если к соседу можно быстрее добоаться через
                                                 #   текущий узел...
         costs[n] = new_cost                     #...обновить стоимость для этого узла
         parents[n] = node                       # Этот узел становится новым родителем для соседа
   processed.append(node)                        # Узел помечается как обработанный
   node = find_lowest_cost_node(costs)           # Найти следующий узел для обработки и повторить
                                                 #  цикл

def find_lowestcost_node(costs):
   lowest_cost = float("inf")
   lowest_cost_node = None
   for node in costs:                            # Перебрать все узлы
      cost = costs[node]
      if cost < lowest_cost and not in processed: # Если это узел с наименьшей стоимостью из уже
                                                  #   виденных и он ещё не был обработан...
         lowest_cost = cost                      #...он назначается новым узлом с наимеьшей
                                                 #   стоимостью
         lowest_cost_node = node
   return lowest_cost_node

```

## Алгоритмы сортировки
#### Пузырьковая сортировка
>[!info] Время выполнения - квадратичное O(n²)

Сортировка массива по возрастанию. Начинаем с начала и движемся к концу. Сравниваем два стоящих рядом значения(0 и 1).
 1. Если второе значение меньше первого - переставляем. Переходим к следующей паре - индексам 1 и 2. Опять сравниваем.
 2. Если второе значение меньше первого - переставляем, и так до конца массива. В конце массива оказалось минимальное значение.
 3. Повторяем так столько раз, сколько элементов в массиве.
 
Использование эффективно для малого набора данных, хотя её мало используют на практике(поскольку O(n²)).

#### Сортировка выбором
>[!info]  Время выполнения - квадратичное O(n²)

Сортировка массива по возрастанию. Находим в цикле минимальное значение и ставим его на первое место. Затем ищем минимальное значение начиная со 2го индекса и ставим его на 2е место. Затем ищем начиная с 3го и т.д.

```
def find Smallest(arr)
    smallest = arr[0]               # Для хранения наименьшего значения
    smallest_index = 0              # Для хранения индекса наименьшего значения
    for i in range(1, len(arr)):
        if arr[i] < smallest:
            smallest = arr[i]
            smallest_index = i
    return smallest_index

# На основе этой функции можно написать функцию сортировки выбором

def sectionSort(arr):                # сортирует массив
    newAr = []
    for i in range(len(arr)):
        smallest = findSmallest(arr)        # Находит наименьший элемент в массиве
        newArr.append(arr.pop(smallest))    # и добавляет его в новый массив
    return newArr
```

#### Сортировка вставками
>[!info]  Время выполнения - квадратичное O(n²)

Сортировка, в которой элементы просматриваются по одному и ставятся на место в соответствии с уже упорядоченным массивом.
1. Первое значение считается отсортированным, начинают со второго. 
2. Второе меньше? Ставим второе в начало(первые два теперь отсортировваны). 
3. Проверяем третье, если меньше второго, сравниваем с первым и т.д.

Использование может быть эффективно, когда данные почти отсортированы

#### Быстрая сортировка
>[!info]  Время выполнения - линейно-логарифмическое время O(N * log N) среднее. В худшем случае выбора опорной точки O(n²). Существует параллельная версия быстрой сортировки, которая сортирует массив за время О(n)

```
def quicksort(array):
   if len(array) < 2:                             #Базовый случай
      return array                                #массивы с 0 и 1 элементом уже "отсортированы"
   else:
      pivot = array[0]                                #Рекурсивный случай
      less = [i for i in array[1:] if i <= pivot]     #Подмассив всех элементов, меньше опорного
      greater = [i for i in array[1:] if i > pivot]   #Подмассив всех элементов, больше опорного
      return quicksort(less) + [pivot] + quicksort(greater)  
```

#### Сортировка слиянием
>[!info]  Время выполнения - линейно-логарифмическое время O(N * log N)

==Сортировка слиянием== — алгоритм рекурсивной сортировки, который непрерывно разделяет список пополам, пока не найдет один и более списков, содержащих один элемент, а затем соединяет их обратно в правильном порядке. Один из наиболее эффективных алгоритмов сортировки, который широко применяется.
В Python функции *sort* и *sorted* - это гибридная реализация(сочетание сортировки слиянием и сортировки вставками)

## Жадные алгоритмы
>[!info] Жадный алгоритм на каждом шаге выбирает то, что представляется лучшим вариантом в данный момент.

Пример вычисления максимального значения в списке O(n)
```
def max(array):
    maximum = array[0]
    for i in array:
        if i > maximum:
            maximum = i
            
    return maximum
```

## Оптимизация алгоритмов
1. Определение текущей эффективности.
2. Определение лучшей эффективности из возможных.
3. Оптимизация поиска(например использвание хэш-таблицы).
4. Выявление закономерностей(например визуализируя множество примеров).
5. Рассмотрение возможности использования жадных алгоритмов.
6. Замена структуры данных.