>[!info] Объектно-ориентированное программирование (сокр. ООП) — методология программирования, основанная на представлении программы в виде совокупности взаимодействующих объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.

Основные принципы структурирования в случае ООП связаны с различными аспектами базового понимания предметной задачи, которое требуется для оптимального управления соответствующей моделью:
- ==абстракция== - это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе.
- ==инкапсуляция== для быстрой и безопасной организации собственно иерархической управляемости: чтобы было достаточно простой команды «что делать», без одновременного уточнения как именно делать, так как это уже другой уровень управления;
- ==наследование== для быстрой и безопасной организации родственных понятий: чтобы было достаточно на каждом иерархическом шаге учитывать только изменения, не дублируя всё остальное, учтённое на предыдущих шагах;
- ==полиморфизм== для определения точки, в которой единое управление лучше распараллелить или наоборот — собрать воедино.

>[!info] Композиция - это встраивание одного класса в другой

Создание класса
```
class User:
    pass
```

Атрибуты класса
```
class User:
    color = 'red'


User.color     # вызов атрибута
```

Создание экземпляра класса
```
a_cat = Cat()
```

Удаление экземпляра класса
```
del a_cat
```

Установка атрибутов объекта
```
a_cat.age = 2
a_cat.name = Nik
```

При создании объекта:
1. Создаётся объект (метод `__new__`)
2. Инициализируется объект (метод `__init__`)

#### `__new__()`
Возвращает ссылку на созданный объект
`return super().__new__(cls)` для вызова вручную из собственного метода `__new__`

Можно использовать для паттерна "Singleton"(когда существует ровно 1 экземпляр класса):
```
class Singleton:
    __instance = None                            # хранит ссылку на экхемпляр класса

    def __new__(cls, *args, **kwargs):
        if cls.__instance is None:                # если экземпляр класса не создан
            cls.__instance = super().__new__(cls) # создаём(возвращаем ссылку на него)
         return cls.__instance              # если создан, то возвращ. ссылку из переменной класса

    def __del__(self):
        Singleton.__instance = None
```

#### `__init__()`
Инициализация(не конструктор)
```
def __init__(self):              # self означает что передаётся экземпляр этого класса
    pass
```

Например:
```
   class Cat():
      def __init__(self, name):
         self.name = name

   a_cat = Cat("Nik")
```

Если переопределяется метод `__init__` для потомка, то родительский метод больше САМ
 не вызывается. Надо его вызывать вручную.
```
 class Volvo(Car):
    def __init__(self):
        super().__init__(self)       # метод super() вызывает родительскую версию любого метода
        print("new code...")
```
либо можно напрямую указать класс и метод, например `Car.__init__(self)`

#### `__del__()`
Код, который выполнится при удалении объекта. "финализатор"
```
def __del__(self):
    pass
```

#### Переменные класса и переменные экземпляра
```
class Dog:  
    num_legs = 4  # Переменная класса  
  
    def __init__(self, name):  
        self.name = name  # Переменная экземпляра  
  
  
alpha = Dog('Alpha')  
omega = Dog('Omega')  
  
Dog.num_legs = 6    # изменяем переменную класса
alpha.num_legs = 2  # создаётся переменная ЭКЗЕМПЛЯРА с тем же именем
omega.num_legs = 1  # создаётся переменная ЭКЗЕМПЛЯРА с тем же именем
  
print(alpha.name, alpha.num_legs, alpha.__class__.num_legs)  # Alpha 2 6
print(omega.name, omega.num_legs)                            # Omega 1
print(Dog.num_legs)                                          # 6
```

Обращение к переменной КЛАССА:
- <название класса>.<переменная класса>
- <экземпляр класса>.\__class__.<переменная класса>

#### Наследование
```
class Volvo(Car):
   pass
```

проверка функцией `issubclass()`
```
>>>issubclass(Volvo, Car)
   True
```

#### Множественное наследование
Если будет вызываться метод объекта, созданного из класса с множ. наследованием, то 
 этот метод Python будет искать в порядке:
1. Сам объект
2. Класс объекта
3. Первый родительский класс
4. Второй родительский класс
5. Прародительский класс

Метод `mro()` показывает список приоритетных методов
например  `print(super.mro())`

#### Свойства для вычисляемых значений
```
class Circle():
    def __init__(self, radius):
        self.radius = radius

    @property
    def diameter(self):
        return 2 * self.radius
```
и теперь диаметр можно вызывать как атрибут:
```
>>>с = Cirlce(5)
>>>c.radius
5
>>>c.diameter
10
```

#### Инкапсуляция
С двумя подчёркиваниями перед именем, переменная становится видна только изнутри класса
`self.__money = 200`
методы с таким именем - напрямую не наследуются

>[!info] Python предлагает именовать атрибуты, которые не должны быть видимы за пределами определения их классов как __

Можно гибко и удобно работать с приватными свойствами с помощью декоратора `@property`
```
class Duck():
    def __init__(self, input_name):
        self.__name = input_name

    @property
    def name(self):
        print('Inside the getter')
        return self.__name

    @name.setter
    def name(self, input_name):
        print('Inside the setter'):
        self.__name = input_name
```

```
>>fowl = Duck('Howard')
>>fowl.name
Inside the getter
'Howard'
>>fowl.name = "Donald"
Inside the setter
'Donald'
```

- attribute (без одного или двух подчеркиваний вначале) – публичное свойство (public)
- _attribute (с одним подчеркиванием) – режим доступа protected (служит для обращения внутри класса и во всех его дочерних классах)
- __attribute (с двумя подчеркиваниями) – режим доступа private (служит для обращения только внутри класса)

#### Методы
###### Методы без декоратора
методы объекта, и первым их аргументом должен быть self
###### Методы @classmethod
это методы класса, и первым их аргументом должен быть cls. Позволяет получать не экземпляр класса в качестве параметра, а сам класс. Влияет на весь класс целиком.
```
class A():
    count = 0
    def __init__(self):
        A.count += 1

    @classmethod
    def kids(cls):
        print('A has', cls.coint, 'objects')
```
Можно вызвать у экземпляра класса или у самого класса

###### Статические методы @staticmethod
Статические методы определяются директивой @staticmethod
Позволяет не получать экземпляр класса в кач. параметра(обычная функция, но в классе)
```
@staticmethod
def func():
    pass
```
Можно вызвать у экземпляра класса или у самого класса

|Метод|Описание|
|------|----------|
|`__getattribute__(self, item)`|Метод автоматич. вызывается, когда считываются атрибуты экземпляра класса. Возвращает значение соответств. атрибута
|`__setattr__(self, key, value)`|Метод автоматич. вызывается, когда устанавливаются атрибуты экземпляра класса.
|`__getattr__(self, item)`|Метод автоматич. вызывается, когда идёт обращение к несуществующему атрибуту экземпляра класса.
|`__delattr__()`|Метод автоматич. вызывается, когда удаляется атрибут экземпляра класса.
|`__call__()`|Отвечает за возможность вызова оператором ()

#### Абстрактные классы
>[!info] Как правило, абстрактные классы объявляют некоторый общий функционал для классов наследников. Причем некоторый функционал может не иметь никакой реализации - его реализацию должны определить классы-наследники. Подобный функционал оформляется в классе в виде абстрактных методов.
>  Мы не можем напрямую создать объект абстрактного класса
>  Классы-наследники должны реализовать все абстрактные методы абстрактного класса.

```
from abc import ABC, abstractmethod

class Base(ABC):
	@abstractmethod
	def foo(self):
		pass
		
	@abstractmethod
	def bar(self):
		pass
```


#### Моносостояние
Используя паттерн "Моносостояние", можно заставить все экземпляры класса иметь общие атрибуты
```
class ThreadData:
    __shared_attrs = {
      'name': 'thread_1',
      'data': {},
      'id': 1
    }

    def __init__(self):
        self.__dict__ = self.__shared_attrs    # __dict__ это словарь с локальными атрибутами 
```