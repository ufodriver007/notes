## Основные принципы безопасности
- целостность данных (изменены ли данные?);
- проверка подлинности (это кто?);
- проверка подлинности данных (кем созданы данные?);
- неопровержимость деяния (кто это сделал?);
- предоставление прав (что можно и что нельзя?);
- неразглашение (у кого есть доступ к данным?)

|Фундаментальный принцип|Архитектурное решение|
|--------|--------|
|Целостность данных|Защищенные сетевые протоколы; Система контроля версий; Диспетчер пакетов;|
|Проверка подлинности|Проверка личности; Проверка подлинности системы;|
|Проверка подлинности данных|Регистрация пользователей; Ввод пользователем учетных данных; Механизм сброса и восстановления пароля; Пользовательские сеансы;|
|Неопровержимость деяния|Посылка данных об операции на сервер; Цифровые подписи; Доверенные третьи стороны;|
|Предоставление прав|Выдача прав пользователям; Выдача прав системам; Выдача прав на доступ к файлам и папкам;|
|Неразглашение|Алгоритмы шифрования; Защищенные сетевые протоколы;|



## Набор компонентов Python, создающий стойкую к атакам многоуровневую систему

![[2024-06-15_18-15.png]]

## hashlib
 - Для большинства задач подходит SHA-256.
 - Для обеспечения высокой безопасности подходит SHA3-256, но за это придется заплатить не настолько широкой поддержкой.
- Для объемных сообщений подходит BLAKE2.
- Ни за что не используйте MD5 либо SHA1 для целей безопасности.
- Функции контрольного суммирования ни за что не должны быть использованы для целей обеспечения безопасности. 

```
import hashlib

x = hashlib.sha256(b'message').hexdigest()  
print(x)  # ab530a13e45914982b79f9b7e3fba994cfd1f3fb22f71cea1afbf02b460c6d1d
```

>[!info] Криптографические хеш-функции и функции контрольного суммирования похожи между собой, но, несмотря на это, путать их не стоит. Для криптографической хеш-функции сложно найти коллизию, но и подсчет занимает больше ресурсов. Контрольная же сумма высчитывается быстро, но найти коллизию среди этих сумм несложно.

#### Случайные числа
>[!info] Ни при каких обстоятельствах не используйте модуль random для оборонных и криптографических задач.
```
import secrets

token_hex = secrets.token_hex(16)          # 840f616fcb1a96df1c16f7127518cf4a
token_urlsafe = secrets.token_urlsafe(16)  # qtT3GDpzYQ0LKLEWlaqB0Q
```

>[!info] Если человеку нужно держать ключ в памяти, используйте кодовую фразу.

Генерация кодовой фразы из четырех слов
```
import secrets  
from pathlib import Path

words = Path('/usr/share/dict/words').read_text().splitlines()  
passphrase = ' '.join(secrets.choice(words) for i in range(4))  
print(passphrase)                           # sleepwalk flatters etymologist slipperier
```

#### HMAC-функции
>[!info] Для проверки подлинности данных используется хеширование с ключом.

HMAC-функции (hash-based message authentication code; код проверки подлинности сообщений, использующий хеш-функции) – распространенный способ применить любую хеш-функцию для проверки подлинности данных, как если бы ей можно было передать ключ.

![[hmac.png]]

```
import hashlib
import hmac

hmac_sha256 = hmac.new(b'key', msg=b'message', digestmod=hashlib.sha256)
print(hmac_sha256.hexdigest())  
# 6e9ef29b75fffc5b7abae527d58fdadb2fe42e7219011976917343065f58ed4a
```

Пример взаимодействия
- Алиса и Боб согласовали общий секретный ключ;
- Боб высчитывает хеш документа через HMAC-функцию;
- Боб отправляет документ и его хеш Алисе;
- Алиса высчитывает хеш документа через HMAC-функцию;
- Алиса сравнивает свой хеш с хешем Боба.

#### Атака по времени
Если хэши сравниваются с помощью оператора `==` это даёт возможность провести атаку по времени. Дело в том что оператор `==` выдает False, как только повстречает первое несоответствие между его операндами. Можно проводить множество сравнений и собирать статистику по времени. И в конце концов обнаружить, что для определённого символа, если он  первый(первые), сравнение идёт дольше. 
>[!info] Безопасные системы сравнивают хеши за постоянное время. Модуль hmac содержит функцию `compare_digest`, которая сравнивает хеши за одинаковое время. Всегда сравнивайте хеши через `compare_digest`.

#### Неразглашение данных. Пакет cryptography
```
pip install cryptography
```
Авторы пакета разделили доступные в нем возможности на две
категории:
- «взрывчатые вещества», нетривиальные низкоуровневые инструменты;
   Уважительных причин лезть сюда практически нет. Разве что:
    - нужно шифровать файлы, которые не помещаются в оперативной памяти;
    - нужно использовать редкий шифр;
- «готовые рецепты», высокоуровневые и несложные в использовании.

#### Симметричное шифрование
>[!info] Если алгоритму шифрования требуется один и тот же ключ как для зашифровки открытого текста, так и для его расшифровки –  такое шифрование называется **симмет­ричным**.

###### Пример использования `fernet` для шифрования текста и проверки подлинности
![[fernet.png]]

```
from cryptography.fernet import Fernet  
  
key = Fernet.generate_key()  
f = Fernet(key)  
token = f.encrypt(b"A really secret message. Not for prying eyes.")  

print(token)  # b'gAAAAABmcwq9kisDN4h83Z-GY4oQty8n6sNKriGSoTcHkVhehHqZWjOGKwANUFfz07zzc-O0v1zDyx4c4y7M7HiM6tuYBS2nvNMa1pJwgQaP2IT0xDHR8MDoxIZXA4uCTYjI3geStRA9'

print(f.decrypt(token))  # b'A really secret message. Not for prying eyes.'
```

![[fernet_decrypt.png]]

Для алгоритма со сменой ключа используйте `MultiFernet`
```
from cryptography.fernet import Fernet, MultiFernet
```

>[!warning] В симметричном шифровании существует проблема передачи ключа – классическая задача криптографии, и у симметричного шифрования нет на нее ответа. На помощь приходит шифрование асимметричное.

#### Асимметричное шифрование
>[!info] Если для зашифровки применяется один ключ, а для расшифровки – другой, то это асимметричное шифрование. Эти два ключа называют парой ключей. Асим­мет­ричное шифрование ещё называют криптосистемой с открытым ключом.

![[assymetric_cypher.png]]

###### RSA
RSA – классический пример криптосистемы с открытым ключом, которая выдержала проверку временем.

Вызов openssll, который генерирует закрытый ключ RSA длиной 3072 бита
```
openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:3072
```

Можно извлечь открытый ключ из файла с закрытым
```
openssl rsa -pubout -in private_key.pem -out public_key.pem
```

Установка разрешений на ключи
```
chmod 600 private_key.pem
chmod 644 public_key.pem
```

Создание пары ключей RSA через Python
```
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa

# Генерация закрытого ключа
private_key = rsa.generate_private_key(public_exponent=65537,
                                       key_size=3072,
                                       backend=default_backend(),)

# Извлечение открытого ключа
public_key = private_key.public_key()
```

>[!tip] Ключи для боевых систем редко генерируются скриптами на Python. Как правило, используются консольные утилиты, как то `openssl` либо `ssh-keygen`.

>[!info] Асимметричное шифрование `работает в обе стороны`. Можно зашифровать послание открытым ключом, а расшифровать закрытым. Или наоборот, можно зашифровать закрытым, а расшифровать открытым. Таким образом, `мы можем быть уверены` только в чем-то одном: `либо в неразглашении`, `либо в подлинности данных`. То, что зашифровано открытым ключом, может расшифровать только владелец закрытого ключа, и, следовательно, не может быть разглашено. При этом создателем содержимого может быть кто угодно. То, что зашифровано закрытым ключом, является подлинным и принадлежит руке владельца закрытого ключа, но расшифровать эти данные может кто угодно. Следовательно, данные разглашаются, но их авторство несомненно.

#### Цифровые подписи
 Цифровые подписи обеспечивают неопровержимость. Тоесть мы однозначно можем узнать оригинальное ли это сообщение.
 
Создание цифровой подписи
![[sign_1.png]]

Проверка цифровой подписи
![[sign_2.png]]

#### TLS
###### Transport Layer Security
- SSL (Secure Sockets Layer, слой защищенных сокетов) – предшест­венник TLS, пользоваться им небезопасно.  Вместо SSL надлежит использовать TLS, который быстрее и безопаснее.
- HTTPS (Hypertext Transfer Protocol Secure, безопасный протокол передачи гипертекста) – просто-напросто HTTP, обернутый в SSL либо TLS.

>[!info] TLS – клиент-серверный протокол. Каждое соединение начинается с процедуры handshake. TLS обеспечивает неразглашение данных и проверку подлинности

Пример handshake TLS 1.3
1. переговоры о наборе шифров(симметричных - с общим ключом);
2. обмен ключами;
3. проверка подлинности сервера.

Используется т.н. протокол Диффи–Хеллмана
1. Алиса и Боб по незащищенному каналу договариваются о двух
простых числах.
2. Каждый из них генерирует свой собственный закрытый ключ.
3. Каждый из них выводит индивидуальный открытый ключ из своего закрытого и двух простых чисел из шага 1.
4. Они обмениваются открытыми ключами по незащищенному каналу.
5. Теперь каждый из них на основе этих данных может вычислить одинаковый ключ, который и будет использован впоследствии для симметричного шифрования.

*Т.е. клиент с сервером соединяются при помощи ассиметричного шифрования(с открытыми и закрытыми ключами) только для того чтобы потом передать общий ключ( ключ на самом деле даже не передается между сторонами соединения, они оба приходят к нему путем взаимных вычислений) и далее общаться с помощью симметричного шифрования(которое ГОРАЗДО быстрее).*

Сервер удостоверяет свою личность отправкой сертификата открытого ключа клиенту. Сертификат содержит открытый ключ сервера и доказывает, что этот ключ действительно принадлежит веб-сервису. Сертификат должен быть издан удостоверяющим центром (certificate authority – CA), специальной уполномоченной организацией. Чтобы любой сервер мог представиться любому клиенту во время рукопожатия TLS, а любой клиент умел проверять личность любого сервера.

![[certificate.png]]

#### Загрузка сертификата
Загрузка сертификата открытого ключа Википедии
```
import ssl  
  
address = ('wikipedia.org', 443)  
certificate = ssl.get_server_certificate(address)  
print(certificate)  
  
with open('certificate.crt', 'w') as f:  
    f.write(certificate)
```

#### Самозаверенные сертификаты
>[!info] Такой сертификат не обеспечит подлинности сервера, так что он подходит для разработки и тестирования сервиса, но не для боевой системы.

Следующие команды создают пару ключей на основе эллиптических кривых и самоподписанный сертификат сроком на 10 лет

```
openssl ecparam -name prime256v1 -genkey -noout -out private_key.pem
```

```
 openssl req -x509 \         # Новый сертификат X.509
-nodes -days 3650 \          # Сроком действия на 10 лет
-key private_key.pem \       # Сертификат удостоверяет открытый ключ который будет выведен                              #  из закрытого. Этим же закрытым ключом сертификат и
                             #  будет подписан.
-out certificate.pem         # Записываем сертификат в файл

# в одну строчку
openssl req -x509 -nodes -days 3650 -key private_key.pem -out certificate.pem
```

>[!info]  HTTPS – забота не Django, а Gunicorn

Запуск Gunicorn с сертификатом открытого ключа
```
gunicorn alice.wsgi \          Модуль alice.wsgi находится в alice/alice/wsgi.py
--keyfile private_key.pem \    Путь к закрытому ключу
--certfile certificate.pem     Путь к сертификату
```

Теперь Gunicorn будет отправлять этот сертификат во время установки HTTPS-соединения.
Поскольку это самоподписанный сертификат, то браузер не никак не может проверить цифровую подпись. Чтобы успешно установить соединение, придется руками добавить этот сертификат в список доверенных(последовательность зависит от ОС).

#### Заголовок ответа `Strict-Transport-Security`
>[!info] Чтобы сообщить браузеру, что в дальнейшем для соединения стоит применять только HTTPS.

Пример заголовка сообщающего, что обращаться к сайту только по HTTPS в течение ближайшего часа
```
Strict-Transport-Security: max-age=3600
```

Настройка Django в settings.py
```
SECURE_HSTS_SECONDS = 3600
```

>[!warning] На боевой системе обращайтесь с SECURE_HSTS_SECONDS осторожно. Заголовок HSTS распространяет действие на весь сайт, а не только на одну страницу. Если что-то пойдет не так, с этим ничего нельзя будет поделать еще в течение всего max-age с момента выключения настройки. Не ставьте сразу большое значение этой директиве на работающем сервисе. Сначала выставьте небольшое, затем постепенно увеличивайте.

Если нужно распространить это и на поддомены

Настройка Django в settings.py
```
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
```

#### Переадресация на HTTPS
Настройка Django в settings.py
```
SECURE_SSL_REDIRECT = True
```

Если включена настройка `SECURE_SSL_REDIRECT` появляется возможность включить
###### `SECURE_REDIRECT_EXEMPT` 
Если URL соответствует какому-либо регулярному выражению из списка SECURE_REDIRECT_EXEMPT, переадресация не производится. Элементами списка должны быть строки с выражениями, без использования re.compile(). По умолчанию список пуст.

###### `SECURE_SSL_HOST`
Если домен для HTTPS отличается от домена для HTTP, используется настройка SECURE_SSL_HOST. Если задать значение, допустим, bob.com, Django перенаправит пользователя с http://alice.com на https://bob.com вместо https://alice.com. Значение по умолчанию – None.

#### Соединение с БД через TLS
```
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": "db_name",
        "HOST": db_hostname,
        "PORT": 5432,
        "USER": "db_user",
        "PASSWORD": db_password,
        "OPTIONS": {
            # Особые настройки, которые различаются между СУБД
            "sslmode": "verify-full",
        },
    }
}
```

>[!warning] Шифрование трафика до сервера БД не исключает шифрования самой базы данных. Всегда шифруйте саму базу в том числе. Загляните в документацию по вашей СУБД, чтобы узнать, как это сделать.

#### Электронная почта

>[!info] Для работы с электронной почтой у Django есть модуль `django.core.mail`, это обертка над модулем `smtplib` самого Python. Для отправки почты используется протокол SMTP (Simple Mail Transfer Protocol, простой протокол передачи почты) через порт 25. SMTP, как и HTTP, родом из 80-х. Он не обеспечивает неразглашения, он не проверяет подлинность клиента либо сервера.

Чтобы в ваши письма нельзя было подсмотреть по пути, вместо SMTP используется SMTPS. Это всего лишь SMTP, обернутый в TLS. 

###### Проверка неразглашения
Настройки Django в `settings.py`(Только одну из них можно включить в `True`)
1. включает режим «только TLS»
```
EMAIL_USE_SSL = True
```
2. нерекомендованный способ с предварительным небезопасным соединением
```
EMAIL_USE_TLS = True
```

###### Проверка личности
```
EMAIL_SSL_KEYFILE = '/path/to/private/key'
EMAIL_SSL_CERTFILE = '/path/to/certificate'
```

>[!warning]  Как и в случае с базой данных, шифрование трафика электронной почты не исключает шифрования хранимых писем. Всегда шифруйте их на жестком диске.

#### Cookie
>[!info] RFC 6265 предписывает HTTP-клиентам поддерживать cookie длиной не меньше 4096 байт (https://datatracker.ietf.org/doc/html/rfc6265#section-6.1). Сookie большей длины могут поддерживаться, но не обязательно. Из-за этого упакованные параметры сеанса должны умещаться в 4 Кб.

Сервер отправляет для установки куки заголовок `Set-Cookie`
```
Set-Cookie: sessionid=cgqbyjpxaoc5x5mmm9ymcqtsbp7w7cn1
```

Браузер  отправляет на сервер куки с заголовком `Cookie`
```
Cookie: sessionid=cgqbyjpxaoc5x5mmm9ymcqtsbp7w7cn1; key=value
```

>[!info] Сookie, присланные с заголовком Set-Cookie, могут содержать некоторые дополнительные атрибуты. С их помощью можно несколько обезопасить cookie идентификатора сеанса

###### Атрибут `Secure`
>[!info] Сервер может противостоять прослушке cookie, снабдив ее атрибутом `Secure`.  Атрибут Secure запрещает браузеру отправлять cookie обратно по HTTP и предписывает делать это только по HTTPS.

```
Set-Cookie: sessionid=<session-id-value>; Secure
```

В Django в `settings.py`
```
SESSION_COOKIE_SECURE = True
```

###### Атрибут `Domain`
>[!info] Атрибут `Domain` указывает хосты, на которые отсылаются куки. Если он не задан, то по умолчанию берётся доменная часть адреса документа (но без поддоменов). Если домен указан явно, то поддомены всегда включены.

```
Set-Cookie: sessionid=<session-id-value>; Domain=alice.com
```

В Django в `settings.py`
```
SESSION_COOKIE_DOMAIN = "alice.com"
```

###### Атрибут `Max-Age`
>[!info] Сервер добавляет атрибут Max-Age, чтобы задать срок действия cookie. Выбор срока действия cookie – это выбор между безопасностью и удобством. 

```
Set-Cookie: sessionid=<session-id-value>; Max-Age=1209600
```

В Django в `settings.py`
```
SESSION_COOKIE_AGE = 1 209 600  # это дефолтное значение(2 недели)
```

#### Django `SECRET_KEY`
Она применяется при хешировании с ключом в качестве ключа. 

Механизм на основе cookie вкупе с `PickleSerializer` – гремучая смесь. Знающий `SECRET_KEY `злоумышленник может сделать с вашим приложением все, что угодно.

>[!warning] Удаленное исполнение кода – одна из разрушительнейших атак. Никогда не выставляйте настройки таким образом, чтобы для механизма на основе cookie параметры сеанса паковал PickleSerializer. Ставки непомерно высоки, вам этого не надо.

Пример:
> Сначала Мэллори пишет код на Python, который сделает чтонибудь плохое. Именно его будет выполнять vulnerable.alice.com. Чтобы запаковать зловреда, она устанавливает Django и прогоняет код через PickleSerializer. От полученной байтовой строки она высчитывает хеш так же, как это сделал бы сервер: с помощью HMAC-функции и `SECRET_KEY`. Итак, верный хеш у нее в руках. Наконец, она склеивает упакованный вредоносный код и хеш, как будто это параметры сеанса, и отправляет vulnerable.alice.com под видом такого cookie. Сервер принимает cookie как родной: хеш совпадает. Конечно, ведь Мэллори знает `SECRET_KEY`. После проверки подлинности «троянского cookie» сервер распаковывает его через `PickleSerializer`, что приводит к выполнению опасной начинки. Мэллори успешно провела атаку удаленного исполнения кода.

#### Проверка личности
![[registration.png]]

