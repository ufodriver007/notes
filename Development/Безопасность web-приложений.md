## Разведка
>[!info]  Построение карты веб-приложения, которая позднее поможет при расстановке приоритетов и планирования сценариев атаки

#### Поиск субдоменов
1. Использование инструментов для разработчиков в браузере для отслеживания запросов
2. Поиск в гуле:
    1. `site:mega-bank.com log in`
    2. `site:reddit.com -inurl:www` (Исключение `www` из запроса, т.к. адреса с `www` это общедоступные адреса)
3. Поиск в архиве [archive.org](https://archive.org/) (В снапшотах разделённых значительным промежутком времени, в коде страницы ищем наиболее распространённые шаблоны URL:
    • `http://`
	• `https://`
	• `file://`
	• `ftp://`
	• `ftps://`)
4. Поиск в соцсетях. Использование API для разработчиков для нечёткого поиска нужных доменов. 
5. Атака на передачу зоны
   1. Находим DNS серверы связанные с искомым доменом
```
host -t NS ya.ru
```
Результат будет примерно такой
```
ya.ru name server ns1.yandex.ru.
ya.ru name server ns2.yandex.ru.
```
   2. Запрос на передачу зоны
```
host -l ya.ru ns1.yandex.ru  # Флаг -l указывает, что мы хотим получить файл зоны для ya.ru с ns1.yandex.ru, чтобы обновить наши записи.
```
Если запрос будет выполнен (что указывает на ошибки в защите DNS-сервера), вы увидите следующий результат:
```
Using domain server:
Name: ns1.bankhost.com
Address: 195.11.100.25
Aliases:

mega-bank.com has address 195.250.100.195
mega-bank.com name server ns1.bankhost.com
mega-bank.com name server ns2.bankhost.com
mail.mega-bank.com has address 82.31.105.140
admin.mega-bank.com has address 32.45.105.144
internal.mega-bank.com has address 25.44.105.144
```
Теперь у нас есть список других веб-приложений, размещенных в домене, а также их общедоступные IP-адреса!

6. Брутфорс(Легко обнаружить в системном журнале, очень долго) или перебор по словарю

#### Поиск API
Метод OPTIONS позволяет узнать какие запросы поддерживаются сервером
```bash
curl -i -X OPTIONS https://sdk.iad-05.braze.com/api/v3/content_cards/sync
# -i                получить заголовки без тела запроса
# -X OPTIONS        указывает нужный метод
```
Если OPTIONS не срабатывает, вручную отправляем разные типы запросов (GET, POST, PUT, PATCH, DELETE)
Также важным пунктом будет определение какого вида данных ждёт API.

#### Обнаружение сторонних зависимостей
Обнаружение клиентских/серверных фреймворков, библиотек, БД чтобы не готовить атаку самому. Её можно будет просто скопировать из базы данных общеизвестных уязвимостей (`Common Vulnerabilities and Exposures, CVE`).

## Нападение
#### XSS(Cross Site Scripting)
- **Хранимый XSS**.  Хранимый XSS — загруженный пользователем вредоносный сценарий, который сохраняется в базе данных, а затем при запросе и просмотре содержащих его данных другими пользователями выполняется на их устройствах. Например вставка скрипта в комментарий.
- **Отраженный XSS**. Пользователь выполняет локальное действие в веб-приложении, и это запускает на устройстве вредоносный сценарий.
- **XSS-атака на базе DOM**. 
- **XSS с мутациями**

#### CSRF(Cross-Site Request Forgery, Подделка межсайтовых запросов)
 CSRF — это распространение вредоносной ссылки, щелчок на которой вызывает выполнение HTTP-запроса GET от имени аутентифицированного пользователя.
Это может быть ссылка или даже изображение. Пример
```html
<img src="https://www.mega-bank.com/transfer?
to_user=<учетная запись хакера>&amount=10000" width="0" height="0" border="0">
```
Можно также подделать форму и отправить запрос POST, PUT и тд

#### XXE-атака
Чаще всего когда конечная точка API принимает данные в формате XML (или подобном ему).
>[!info] Спецификация XML позволяет подключать к документу дополнительные компоненты — так называемые внешние сущности. Если XML-анализатор не проводит соответствующую проверку, он может просто загрузить внешнюю сущность и подключить к содержимому XML-документа и таким образом скомпрометировать файлы в файловой структуре сервера.

#### Внедрение кода
- SQL-injection

#### DoS
- DDoS (distributed denial of service)
- ReDoS (regular-expression-based DoS)

#### Эксплуатация сторонних зависимостей
Сайт, который анализирует зависимости другого web-приложения [BuiltWith](https://builtwith.com/)

## Защита
###### Регрессивное тестирование
Написание теста, который подтвердит, что исправление сработало и уязвимости больше нет.

###### Шифрование(TLS)
Переход на https

###### Стойкие пароли пользователей
Длинные пароли с высокой энтропией(мерой неопределённости)
Стойкое шифрование данных на сервере

###### Двухфакторная аутентификация

#### Этапы
- Планирование безопасной архитектуры
- Проверка безопасности кода

*Типичная схема проверки кода*:
1. Оценка на стороне клиента с целью понять бизнес-логику и определить предназначенную для пользователей функциональность.
2. Переход к оценке API, обнаруженных в процессе обзора кода на стороне клиента. На этом этапе можно получить хорошее представление о зависимостях, на которые опирается функционирование на уровне API.
3. Проверка зависимостей на уровне API путем внимательного просмотра баз данных, вспомогательных библиотек, функциональности для регистрации и входа в систему и т. п. Эта оценка покрывает большую часть функциональных возможностей пользователей.
4. Теперь, когда известна структура связанных с клиентом API, попытаемся найти любые общедоступные API, которые могут быть открыты непреднамеренно или предназначены для будущего функционала.
5. Продолжаем до конца кодовой базы. На этом этапе все достаточно просто, потому что мы уже хорошо с ней познакомились и не приходится тратить силы на попытки понять архитектуру приложения.

#### Антипаттерны
- Чёрные списки (используйте белые списки)
- Шаблонный код
- Доверие по умолчанию (Всегда сужайте полномочия, если нет надобности)
- Слишком тесный и зависимый друг от друга код сервера и клиента

#### Поиск уязвимостей
###### Статический анализ (без запуска программы)
Bandit (Python — бесплатный);
[Статья на Хабре](https://habr.com/ru/companies/macloud/articles/563246/)

###### Динамический анализ
Selenium

## Чек-лист для Django
- Настройки для `settings.py`
```python
DEBUG = False

ALLOWED_HOSTS = ['your_domain', 'www.your_domain']

SECURE_SSL_REDIRECT = True
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True
SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")
SECURE_HSTS_SECONDS = 31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True
```
- Смена дефолтного пути админки на рандомный
```python
urlpatterns = [
    path('whjbfgwilbefvbwoeuibfuiwb/', admin.site.urls),
]
```

- Также перед деплоем советую проверять проект с помощью `django-admin check --deploy --fail-level WARNING`
Есть онлайн ресурс, так скажем [black box проверка](https://djcheckup.com/)

- [django-allauth](https://github.com/pennersr/django-allauth): Добавляет функции для управления учетными записями, включая регистрацию, аутентификацию и управление паролями.

- [django-csp](https://django-csp.readthedocs.io/en/latest/configuration.html): Устанавливает Content Security Policy (CSP) для защиты от XSS. [ТУТ](https://csp-evaluator.withgoogle.com/) вы можете достать сэмпл безопасной конфигурации CSP, а [ТУТ](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) посмотреть все возможные атрибуты для CSP

- [django-admin-honeypot](https://github.com/dmpayton/django-admin-honeypot): фейковая админка
```python
urlpatterns = [
    ...
    path('admin/', include('admin_honeypot.urls', namespace='admin_honeypot')),
    path('whjbfgwilbefvbwoeuibfuiwb/', admin.site.urls),
]
```

- [django-ratelimit](https://django-ratelimit.readthedocs.io/en/stable): простое ограничение на кол-во запросов с одного IP
```python
@ratelimit(key='ip', rate='10/s')
def secondview(request):
    # ...
```

- [django-defender](https://github.com/jazzband/django-defender): защита от брутфорса и также rate limit, на основе IP и username'а. В отличии от axes, используется отдельная Redis, а не PG самого проекта.Из удобного, данную либу можно "вставить" в админку. Это удобно) 

- [django-guardian](https://github.com/django-guardian/django-guardian): эта либа позволяет гибко управлять разрешениями для объеков Django. Из коробки у нас есть django.contrib.auth. Более подробно [ТУТ](https://gadjimuradov.ru/post/django-guardian-dobavlyaem-upravlenie-razresheniyami-na-urovne-obektov/) читать.

- [django-guardian для DRF](https://github.com/rpkilby/django-rest-framework-guardian): тоже самое, но для Django Rest Framework

- Дополнительный способ защиты - [отслеживание свежих CVE в Django](https://www.cvedetails.com/vulnerability-list/vendor_id-10199/product_id-18211/Djangoproject-Django.html)

## Основные принципы безопасности
- целостность данных (изменены ли данные?);
- проверка подлинности (это кто?);
- проверка подлинности данных (кем созданы данные?);
- неопровержимость деяния (кто это сделал?);
- предоставление прав (что можно и что нельзя?);
- неразглашение (у кого есть доступ к данным?)

|Фундаментальный принцип|Архитектурное решение|
|--------|--------|
|Целостность данных|Защищенные сетевые протоколы; Система контроля версий; Диспетчер пакетов;|
|Проверка подлинности|Проверка личности; Проверка подлинности системы;|
|Проверка подлинности данных|Регистрация пользователей; Ввод пользователем учетных данных; Механизм сброса и восстановления пароля; Пользовательские сеансы;|
|Неопровержимость деяния|Посылка данных об операции на сервер; Цифровые подписи; Доверенные третьи стороны;|
|Предоставление прав|Выдача прав пользователям; Выдача прав системам; Выдача прав на доступ к файлам и папкам;|
|Неразглашение|Алгоритмы шифрования; Защищенные сетевые протоколы;|



## Набор компонентов Python, создающий стойкую к атакам многоуровневую систему

![[2024-06-15_18-15.png]]

## hashlib
 - Для большинства задач подходит SHA-256.
 - Для обеспечения высокой безопасности подходит SHA3-256, но за это придется заплатить не настолько широкой поддержкой.
- Для объемных сообщений подходит BLAKE2.
- Ни за что не используйте MD5 либо SHA1 для целей безопасности.
- Функции контрольного суммирования ни за что не должны быть использованы для целей обеспечения безопасности. 

```python
import hashlib

x = hashlib.sha256(b'message').hexdigest()  
print(x)  # ab530a13e45914982b79f9b7e3fba994cfd1f3fb22f71cea1afbf02b460c6d1d
```

>[!info] Криптографические хеш-функции и функции контрольного суммирования похожи между собой, но, несмотря на это, путать их не стоит. Для криптографической хеш-функции сложно найти коллизию, но и подсчет занимает больше ресурсов. Контрольная же сумма высчитывается быстро, но найти коллизию среди этих сумм несложно.

#### Случайные числа
>[!info] Ни при каких обстоятельствах не используйте модуль random для оборонных и криптографических задач.
```python
import secrets

token_hex = secrets.token_hex(16)          # 840f616fcb1a96df1c16f7127518cf4a
token_urlsafe = secrets.token_urlsafe(16)  # qtT3GDpzYQ0LKLEWlaqB0Q
```

>[!info] Если человеку нужно держать ключ в памяти, используйте кодовую фразу.

Генерация кодовой фразы из четырех слов
```python
import secrets  
from pathlib import Path

words = Path('/usr/share/dict/words').read_text().splitlines()  
passphrase = ' '.join(secrets.choice(words) for i in range(4))  
print(passphrase)                           # sleepwalk flatters etymologist slipperier
```

#### HMAC-функции
>[!info] Для проверки подлинности данных используется хеширование с ключом.

HMAC-функции (`hash-based message authentication code`; код проверки подлинности сообщений, использующий хеш-функции) – распространенный способ применить любую хеш-функцию для проверки подлинности данных, как если бы ей можно было передать ключ.

![[hmac.png]]

```python
import hashlib
import hmac

hmac_sha256 = hmac.new(b'key', msg=b'message', digestmod=hashlib.sha256)
print(hmac_sha256.hexdigest())  
# 6e9ef29b75fffc5b7abae527d58fdadb2fe42e7219011976917343065f58ed4a
```

Пример взаимодействия
- Алиса и Боб согласовали общий секретный ключ;
- Боб высчитывает хеш документа через HMAC-функцию;
- Боб отправляет документ и его хеш Алисе;
- Алиса высчитывает хеш документа через HMAC-функцию;
- Алиса сравнивает свой хеш с хешем Боба.

#### Атака по времени
Если хэши сравниваются с помощью оператора `==` это даёт возможность провести атаку по времени. Дело в том что оператор `==` выдает False, как только повстречает первое несоответствие между его операндами. Можно проводить множество сравнений и собирать статистику по времени. И в конце концов обнаружить, что для определённого символа, если он  первый(первые), сравнение идёт дольше. 
>[!info] Безопасные системы сравнивают хеши за постоянное время. Модуль hmac содержит функцию `compare_digest`, которая сравнивает хеши за одинаковое время. Всегда сравнивайте хеши через `compare_digest`.

```python
from hmac import compare_digest

compare_digest('alice', 'mallory')  # False
```

#### Неразглашение данных. Пакет cryptography
```bash
pip install cryptography
```
Авторы пакета разделили доступные в нем возможности на две
категории:
- «взрывчатые вещества», нетривиальные низкоуровневые инструменты;
   Уважительных причин лезть сюда практически нет. Разве что:
    - нужно шифровать файлы, которые не помещаются в оперативной памяти;
    - нужно использовать редкий шифр;
- «готовые рецепты», высокоуровневые и несложные в использовании.

#### Симметричное шифрование
>[!info] Если алгоритму шифрования требуется один и тот же ключ как для зашифровки открытого текста, так и для его расшифровки –  такое шифрование называется **симмет­ричным**.

###### Пример использования `fernet` для шифрования текста и проверки подлинности
![[fernet.png]]

Под капотом у Fernet используется AES. Блочное шифрование.

```bash
pip install cryptography
```

```python
from cryptography.fernet import Fernet  
  
key = Fernet.generate_key()  
f = Fernet(key)  
token = f.encrypt(b"A really secret message. Not for prying eyes.")  

print(token)  # b'gAAAAABmcwq9kisDN4h83Z-GY4oQty8n6sNKriGSoTcHkVhehHqZWjOGKwANUFfz07zzc-O0v1zDyx4c4y7M7HiM6tuYBS2nvNMa1pJwgQaP2IT0xDHR8MDoxIZXA4uCTYjI3geStRA9'

print(f.decrypt(token))  # b'A really secret message. Not for prying eyes.'
```

![[fernet_decrypt.png]]

Для алгоритма со сменой ключа используйте `MultiFernet`
```python
from cryptography.fernet import Fernet, MultiFernet
```

>[!warning] В симметричном шифровании существует проблема передачи ключа – классическая задача криптографии, и у симметричного шифрования нет на нее ответа. На помощь приходит шифрование асимметричное.

#### Асимметричное шифрование
>[!info] Если для зашифровки применяется один ключ, а для расшифровки – другой, то это асимметричное шифрование. Эти два ключа называют парой ключей. Асим­мет­ричное шифрование ещё называют криптосистемой с открытым ключом.

![[assymetric_cypher.png]]

###### RSA
RSA – классический пример криптосистемы с открытым ключом, которая выдержала проверку временем.

Вызов openssll, который генерирует закрытый ключ RSA длиной 3072 бита
```bash
openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:3072
```

Можно извлечь открытый ключ из файла с закрытым
```bash
openssl rsa -pubout -in private_key.pem -out public_key.pem
```

Установка разрешений на ключи
```bash
chmod 600 private_key.pem
chmod 644 public_key.pem
```

Создание пары ключей RSA через Python
```python
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa

# Генерация закрытого ключа
private_key = rsa.generate_private_key(public_exponent=65537,
                                       key_size=3072,
                                       backend=default_backend(),)

# Извлечение открытого ключа
public_key = private_key.public_key()
```

>[!tip] Ключи для боевых систем редко генерируются скриптами на Python. Как правило, используются консольные утилиты, как то `openssl` либо `ssh-keygen`.

>[!info] Асимметричное шифрование `работает в обе стороны`. Можно зашифровать послание открытым ключом, а расшифровать закрытым. Или наоборот, можно зашифровать закрытым, а расшифровать открытым. Таким образом, `мы можем быть уверены` только в чем-то одном: `либо в неразглашении`, `либо в подлинности данных`. То, что зашифровано открытым ключом, может расшифровать только владелец закрытого ключа, и, следовательно, не может быть разглашено. При этом создателем содержимого может быть кто угодно. То, что зашифровано закрытым ключом, является подлинным и принадлежит руке владельца закрытого ключа, но расшифровать эти данные может кто угодно. Следовательно, данные разглашаются, но их авторство несомненно.

#### Цифровые подписи
 Цифровые подписи обеспечивают неопровержимость. Тоесть мы однозначно можем узнать оригинальное ли это сообщение.
 
Создание цифровой подписи
![[sign_1.png]]

Проверка цифровой подписи
![[sign_2.png]]

#### TLS
###### Transport Layer Security
- SSL (Secure Sockets Layer, слой защищенных сокетов) – предшест­венник TLS, пользоваться им небезопасно.  Вместо SSL надлежит использовать TLS, который быстрее и безопаснее.
- HTTPS (Hypertext Transfer Protocol Secure, безопасный протокол передачи гипертекста) – просто-напросто HTTP, обернутый в SSL либо TLS.

>[!info] TLS – клиент-серверный протокол. Каждое соединение начинается с процедуры handshake. TLS обеспечивает неразглашение данных и проверку подлинности

Пример handshake TLS 1.3
1. переговоры о наборе шифров(симметричных - с общим ключом);
2. обмен ключами;
3. проверка подлинности сервера.

Используется т.н. протокол Диффи–Хеллмана
1. Алиса и Боб по незащищенному каналу договариваются о двух
простых числах.
2. Каждый из них генерирует свой собственный закрытый ключ.
3. Каждый из них выводит индивидуальный открытый ключ из своего закрытого и двух простых чисел из шага 1.
4. Они обмениваются открытыми ключами по незащищенному каналу.
5. Теперь каждый из них на основе этих данных может вычислить одинаковый ключ, который и будет использован впоследствии для симметричного шифрования.

*Т.е. клиент с сервером соединяются при помощи ассиметричного шифрования(с открытыми и закрытыми ключами) только для того чтобы потом передать общий ключ( ключ на самом деле даже не передается между сторонами соединения, они оба приходят к нему путем взаимных вычислений) и далее общаться с помощью симметричного шифрования(которое ГОРАЗДО быстрее).*

Сервер удостоверяет свою личность отправкой сертификата открытого ключа клиенту. Сертификат содержит открытый ключ сервера и доказывает, что этот ключ действительно принадлежит веб-сервису. Сертификат должен быть издан удостоверяющим центром (certificate authority – CA), специальной уполномоченной организацией. Чтобы любой сервер мог представиться любому клиенту во время рукопожатия TLS, а любой клиент умел проверять личность любого сервера.

![[certificate.png]]

#### Загрузка сертификата
Загрузка сертификата открытого ключа Википедии
```python
import ssl  
  
address = ('wikipedia.org', 443)  
certificate = ssl.get_server_certificate(address)  
print(certificate)  
  
with open('certificate.crt', 'w') as f:  
    f.write(certificate)
```

#### Самозаверенные сертификаты
>[!info] Такой сертификат не обеспечит подлинности сервера, так что он подходит для разработки и тестирования сервиса, но не для боевой системы.

Следующие команды создают пару ключей на основе эллиптических кривых и самоподписанный сертификат сроком на 10 лет

```bash
openssl ecparam -name prime256v1 -genkey -noout -out private_key.pem
```

```bash
 openssl req -x509 \         # Новый сертификат X.509
-nodes -days 3650 \          # Сроком действия на 10 лет
-key private_key.pem \       # Сертификат удостоверяет открытый ключ который будет выведен                              #  из закрытого. Этим же закрытым ключом сертификат и
                             #  будет подписан.
-out certificate.pem         # Записываем сертификат в файл

# в одну строчку
openssl req -x509 -nodes -days 3650 -key private_key.pem -out certificate.pem
```

>[!info]  HTTPS – забота не Django, а Gunicorn

Запуск Gunicorn с сертификатом открытого ключа
```bash
gunicorn alice.wsgi \          Модуль alice.wsgi находится в alice/alice/wsgi.py
--keyfile private_key.pem \    Путь к закрытому ключу
--certfile certificate.pem     Путь к сертификату
```

Теперь Gunicorn будет отправлять этот сертификат во время установки HTTPS-соединения.
Поскольку это самоподписанный сертификат, то браузер не никак не может проверить цифровую подпись. Чтобы успешно установить соединение, придется руками добавить этот сертификат в список доверенных(последовательность зависит от ОС).

#### Заголовок ответа `Strict-Transport-Security`
>[!info] Чтобы сообщить браузеру, что в дальнейшем для соединения стоит применять только HTTPS.

Пример заголовка сообщающего, что обращаться к сайту только по HTTPS в течение ближайшего часа
```
Strict-Transport-Security: max-age=3600
```

Настройка Django в settings.py
```python
SECURE_HSTS_SECONDS = 3600
```

>[!warning] На боевой системе обращайтесь с SECURE_HSTS_SECONDS осторожно. Заголовок HSTS распространяет действие на весь сайт, а не только на одну страницу. Если что-то пойдет не так, с этим ничего нельзя будет поделать еще в течение всего max-age с момента выключения настройки. Не ставьте сразу большое значение этой директиве на работающем сервисе. Сначала выставьте небольшое, затем постепенно увеличивайте.

Если нужно распространить это и на поддомены

Настройка Django в settings.py
```python
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
```

#### Переадресация на HTTPS
Настройка Django в settings.py
```python
SECURE_SSL_REDIRECT = True
```

Если включена настройка `SECURE_SSL_REDIRECT` появляется возможность включить
###### `SECURE_REDIRECT_EXEMPT` 
Если URL соответствует какому-либо регулярному выражению из списка SECURE_REDIRECT_EXEMPT, переадресация не производится. Элементами списка должны быть строки с выражениями, без использования re.compile(). По умолчанию список пуст.

###### `SECURE_SSL_HOST`
Если домен для HTTPS отличается от домена для HTTP, используется настройка SECURE_SSL_HOST. Если задать значение, допустим, bob.com, Django перенаправит пользователя с http://alice.com на https://bob.com вместо https://alice.com. Значение по умолчанию – None.

#### Соединение с БД через TLS
```python
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": "db_name",
        "HOST": db_hostname,
        "PORT": 5432,
        "USER": "db_user",
        "PASSWORD": db_password,
        "OPTIONS": {
            # Особые настройки, которые различаются между СУБД
            "sslmode": "verify-full",
        },
    }
}
```

>[!warning] Шифрование трафика до сервера БД не исключает шифрования самой базы данных. Всегда шифруйте саму базу в том числе. Загляните в документацию по вашей СУБД, чтобы узнать, как это сделать.

#### Электронная почта

>[!info] Для работы с электронной почтой у Django есть модуль `django.core.mail`, это обертка над модулем `smtplib` самого Python. Для отправки почты используется протокол SMTP (Simple Mail Transfer Protocol, простой протокол передачи почты) через порт 25. SMTP, как и HTTP, родом из 80-х. Он не обеспечивает неразглашения, он не проверяет подлинность клиента либо сервера.

Чтобы в ваши письма нельзя было подсмотреть по пути, вместо SMTP используется SMTPS. Это всего лишь SMTP, обернутый в TLS. 

###### Проверка неразглашения
Настройки Django в `settings.py`(Только одну из них можно включить в `True`)
1. включает режим «только TLS»
```python
EMAIL_USE_SSL = True
```
2. нерекомендованный способ с предварительным небезопасным соединением
```python
EMAIL_USE_TLS = True
```

###### Проверка личности
```python
EMAIL_SSL_KEYFILE = '/path/to/private/key'
EMAIL_SSL_CERTFILE = '/path/to/certificate'
```

>[!warning]  Как и в случае с базой данных, шифрование трафика электронной почты не исключает шифрования хранимых писем. Всегда шифруйте их на жестком диске.

#### Cookie
>[!info] RFC 6265 предписывает HTTP-клиентам поддерживать cookie длиной не меньше 4096 байт (https://datatracker.ietf.org/doc/html/rfc6265#section-6.1). Сookie большей длины могут поддерживаться, но не обязательно. Из-за этого упакованные параметры сеанса должны умещаться в 4 Кб.

Сервер отправляет для установки куки заголовок `Set-Cookie`
```
Set-Cookie: sessionid=cgqbyjpxaoc5x5mmm9ymcqtsbp7w7cn1
```

Браузер  отправляет на сервер куки с заголовком `Cookie`
```
Cookie: sessionid=cgqbyjpxaoc5x5mmm9ymcqtsbp7w7cn1; key=value
```

>[!info] Сookie, присланные с заголовком Set-Cookie, могут содержать некоторые дополнительные атрибуты. С их помощью можно несколько обезопасить cookie идентификатора сеанса

###### Атрибут `Secure`
>[!info] Сервер может противостоять прослушке cookie, снабдив ее атрибутом `Secure`.  Атрибут Secure запрещает браузеру отправлять cookie обратно по HTTP и предписывает делать это только по HTTPS.

```
Set-Cookie: sessionid=<session-id-value>; Secure
```

В Django в `settings.py`
```
SESSION_COOKIE_SECURE = True
```

###### Атрибут `Domain`
>[!info] Атрибут `Domain` указывает хосты, на которые отсылаются куки. Если он не задан, то по умолчанию берётся доменная часть адреса документа (но без поддоменов). Если домен указан явно, то поддомены всегда включены.

```
Set-Cookie: sessionid=<session-id-value>; Domain=alice.com
```

В Django в `settings.py`
```python
SESSION_COOKIE_DOMAIN = "alice.com"
```

###### Атрибут `Max-Age`
>[!info] Сервер добавляет атрибут Max-Age, чтобы задать срок действия cookie. Выбор срока действия cookie – это выбор между безопасностью и удобством. 

```
Set-Cookie: sessionid=<session-id-value>; Max-Age=1209600
```

В Django в `settings.py`
```python
SESSION_COOKIE_AGE = 1 209 600  # это дефолтное значение(2 недели)
```

#### Django `SECRET_KEY`
Она применяется при хешировании с ключом в качестве ключа. 

Механизм на основе cookie вкупе с `PickleSerializer` – гремучая смесь. Знающий `SECRET_KEY `злоумышленник может сделать с вашим приложением все, что угодно.

>[!warning] Удаленное исполнение кода – одна из разрушительнейших атак. Никогда не выставляйте настройки таким образом, чтобы для механизма на основе cookie параметры сеанса паковал PickleSerializer. Ставки непомерно высоки, вам этого не надо.

Пример:
> Сначала Мэллори пишет код на Python, который сделает чтонибудь плохое. Именно его будет выполнять vulnerable.alice.com. Чтобы запаковать зловреда, она устанавливает Django и прогоняет код через PickleSerializer. От полученной байтовой строки она высчитывает хеш так же, как это сделал бы сервер: с помощью HMAC-функции и `SECRET_KEY`. Итак, верный хеш у нее в руках. Наконец, она склеивает упакованный вредоносный код и хеш, как будто это параметры сеанса, и отправляет vulnerable.alice.com под видом такого cookie. Сервер принимает cookie как родной: хеш совпадает. Конечно, ведь Мэллори знает `SECRET_KEY`. После проверки подлинности «троянского cookie» сервер распаковывает его через `PickleSerializer`, что приводит к выполнению опасной начинки. Мэллори успешно провела атаку удаленного исполнения кода.

#### Проверка личности
###### Засолка паролей
>[!info] Для каждого пароля должна быть своя рандомная соль. Это делает бессмысленным применение к слитым хэшам радужных таблиц.  Соль - не является секретными данными и включена в итоговую строку хэша. При проверке достаём из БД итоговую хэш строку и получаем из неё соль и последнюю часть (которая хэш из пароля и соли).  Алгоритм `bcrypt`  хэширует пользовательский ввод + соль (это должно полностью совпасть с последней частью итоговой хэш строки из БД)

```
# строго 60 символов
$2b$12$S223D5sFpE9fTKl0xYbJZeX9Q8Wz7aCv1dO0rR4tGyB5nH6v.1

$2b$   12$   S223D5sFpE9fTKl0xYbJZe   X9Q8Wz7aCv1dO0rR4tGyB5nH6v.1

#   Алгоритм: $2b$
#   Сложность: 12$ (`12` - число итераций = 2¹² = 4096 раундов)
#   Соль: S223D5sFpE9fTKl0xYbJZe (22 символа) Соответствует 16 байтам случайных данных
#   Хэш: X9Q8Wz7aCv1dO0rR4tGyB5nH6v.1 (31 символ) bcrypt(пароль + соль)
```

###### Функция формирования ключа
>[!info] Функции формирования ключа, они же функции диверсификации ключа занимают особое место. Им не только позволено, от них *требуется* потреблять значительное количество вычислительных мощностей. Чем сильнее они нагружают компьютер, тем затратнее взломать хеш полным перебором.

Функции формирования ключа принимают на вход сообщение, соль и не менее одного параметра, регулирующего прожорливость.
![[argon.png]]

Примеры таких функций:
- Password-Based Key Derivation Function 2 (именно ей Django хэширует пароли)
- Argon2 (устойчива к атакам использующим для вычислений GPU. Это ваш выбор если это новый проект Django)

Установка `Argon2` в качестве функции для хэширования паролей в `Django`
```bash
pip install django[argon2]
```

```python
# settings.py
PASSWORD_HASHERS = [  
     "django.contrib.auth.hashers.Argon2PasswordHasher",  
]
```

#### OAuth
Основной тип авторизации в `OAuth` - *процесс предоставления кода авторизации*. Он разбит на четыре основных этапа:
1. Запрос авторизации
![[auth1.png]]
2. Предоставление авторизации
![[auth2.png]]
3. Обмен токенами
![[auth3.png]]
4. Доступ к защищённым ресурсам
![[auth4.png]]

Объяснение *процесса предоставления кода авторизации* в картинке
![[2025-06-11_11-16.png]]

#### Файловая система
Используйте модуль `subprocess` для выполнения комманд, т.к. он сам по себе безопасен для атак внедрения кода
```python
import subprocess

command = ['cat', 'test.txt']
completed_process = subprocess.run(command, capture_output=True, check=True) 
# Поулчаем вывод терминала 
print(completed_process.stdout)
```

#### YAML
>[!info] Если вы читаете YAML, позаботьтесь о МИНИМАЛЬНЫХ привилегиях загрузчика YAML. В противном случае вы можете выполнить произвольный код у себя на сервере.

#### XML
>[!info] Для парсинга XML документов используйте `defusedxml`. Эта обёртка предотвратит различные атаки *внедрения кода*, имеющие цель исчерпать ресурсы (оперативную память) или атаки *отказ в обслуживании*.

```bash
pip install defusedxml
```

```python
# Вместо родного парсера
# from xml.etree.ElementTree import parse
# Используйте этот
from defusedxml.ElementTree import parse

et = parse(xmlfile)
```

#### DoS
>[!warning] Любое свойство HTTP-запроса может быть использовано в качестве оружия, включая размер, длину URL, количество и размеры полей, размер выгружаемого файла, количество и размеры заголовков

##### Параметры Django для защиты от DoS-атак

==DATA_UPLOAD_MAX_NUMBER_FIELDS==  Задает максимальное количество параметров запроса. Django вызовет исключение SuspiciousOperation, если это число будет превышено. По умолчанию данный параметр имеет значение 1000, но законные HTTP-запросы редко имеют такое количество полей

==DATA_UPLOAD_MAX_MEMORY_SIZE== Ограничивает максимальный размер тела запроса в байтах. Эта проверка не относится к размеру выгружаемых файлов. Django вызовет исключение SuspiciousOperation, если размер тела запроса превысит этот предел

==FILE_UPLOAD_MAX_MEMORY_SIZE== Определяет максимальный размер выгружаемого файла в байтах до того, как он будет записан из памяти на диск. Этот параметр нацелен на ограничение потребления памяти; он не ограничивает размер выгружаемого файла

##### Аргументы Gunicorn  для защиты от DoS-атак

==limit-request-line== Определяет предельный размер строки запроса в байтах. Строка запроса включает метод HTTP, версию протокола и URL. URL является очевидным ограничивающим фактором. По умолчанию этот параметр имеет значение 4094; максимальное значение – 8190. Присваивание этому параметру значения 0 отключает проверку

==limit-request-fields==  Ограничивает количество заголовков HTTP в запросе. К числу «полей»,  количество которых ограничивается этим параметром, не относятся поля форм. По умолчанию параметр имеет разумное значение 100. Максимальное значение limit-request-fields составляет 32 768

==limit-request-field_size== Определяет максимально допустимый размер заголовка HTTP. Символ подчеркивания – это не опечатка. Значение по умолчанию – 8190. Присваивание этому параметру значения 0 разрешает заголовки неограниченного размера. Эта проверка также обычно выполняется веб-серверами

#### Атаки использующие заголовок Host
Если в коде нужен хост, НИКОГДА не берите его из `request.META['HOST']`, потому что в таком случае не проводится проверка заголовка. Запрос может быть подделан. Нельзя просто так полагаться на эти данные!

Пример как нужно извлекать заголовок Host. Функция `get_host()` сверяется с `ALLOWED_HOSTS`
```python
good_practice = request.get_host() # Проверяет и извлекает заголовок Host
```

Никогда не используйте `*` в `ALLOWED_HOSTS`, поскольку это полностью отключит проверку заголовка `Host`!

![[new_host_attack.png]]

#### Непроверенная переадресация
Содержимое URL и атак с непроверенной переадресацией
![[redirect.png]]
![[redirect1.png]]

Код Django с непроверенным редиректом
```python
from django.views import View
from django.shortcuts import redirect

class OpenRedirectView(View):
    def get(self, request):
        ...
        next = request.GET.get('next')
        return redirect(next)
```

Пример, как нужно препядствовать атакам с непроверенной переадресацией
```python
from django.http import HttpResponseBadRequest
from django.utils.http import url_has_allowed_host_and_scheme

class ValidatedRedirectView(View):
    def get(self, request):
        ...
        next = request.GET.get('next)
        host = request.get_host()  # Надёжно определяем имя хоста
        # Проверяем хост и протокол для переадресации
        if url_has_allowed_host_and_scheme(next, host, require_https=True):
            return redirect(next)

        return HttpResponseBadRequest()
```

#### XSS
Cross site scripting. Суть: злоумышленник внедряет вредоносный код в браузер другого пользователя. Вредоносным может быть код JavaScript, HTML, CSS. Этот код может попасть в браузер разными путями: в теле, URL или заголовке HTTP-запроса.

###### Хранимый XSS
Уязвимая система позволяет сохранить вредоносный код. Например на странице в соц.сети, и затем код исполнится у каждого бразера, который это отобразит.
![[new_xss1.png]]

###### Отражённый XSS
Вредоносная ссылка, например сценарий, встроенный в URL
```
https://search.alice.com/?terms=%3Cscript%3Edocument.location=%27https://search.mallory.com%27%3C/script%3E
```
Мэллори отправляет этот URL Бобу в текстовом сообщении. Он попадается на приманку и щелкает на ссылке, непреднамеренно отправляя вредоносный код на search.alice.com. Сайт немедленно отражает вредоносный код Мэллори обратно Бобу. Затем браузер Боба запускает вредоносный сценарий, отображая страницу результатов. Наконец, он переадресуется на search.mallory.com, где Мэллори пытается развить успех.
![[new_xss2.png]]

###### XSS на основе DOM
Злоумышленник инициирует XSS на основе DOM, обманом заставляя пользователя отправить вредоносный контент на уязвимый сайт. В отличие от атаки отраженным XSS, контент не отражается и внедрение происходит в браузере.

###### Защита
Защита от XSS - это пример *глухой обороны*. Здесь нужно использовать комплекс средств.
- Проверка ввода. Всегда валидируйте данные из полей ввода.
- Экранирование вывода (самый важный уровень защиты)
- Заголовки ответа

Заголовки ответов – очень важный уровень защиты от XSS. Этот уровень может полностью предотвратить одни атаки и ограничить ущерб от других.
- отключение доступа к cookie из Java­Script (`Set-Cookie` с директивой `HttpOnly`)
- отключение анализа типа MIME  (заголовок  `X-Content-Type-Options: nosniff`. В Djnago по-умолчанию)

![[new_xss_f.png]]
`Сookie` с идентификатором сеанса всегда должен включать директиву `HttpOnly`. `Django` добавляет ее по умолчанию. Это поведение настраивается параметром `SESSION_COOKIE_HTTPONLY`, который, к счастью, имеет значение по умолчанию `True`.

Пример установки пользовательской куки
```python
...
response = HttpResponse()
response.set_cookie(
    'cookie-name',
    'cookie-value',
    httponly=True)
...
```

#### Политики защиты содержимого
>[!info] Политика передается в браузер с сервера с по­мощью заголовка ответа `Content-Security-Policy` и применяется только к полученному ответу. CSP – один из самых простых уровней защиты.

Пример запрещающий браузеру выполнять код на JavaScript
```
Content-Security-Policy: script-src 'none'
```

![[scp.png]]

>[!info] Типичная политика состоит из нескольких директив, разделенных точкой с запятой, с одним или несколькими источниками, разделенными пробелами.

Пример политики, разрешающей браузеру получать любые сценарии через HTTPS, несмотря на источник `none`.
```
Content-Security-Policy: script-src 'none' https:
```

###### Управление политиками `SCP` в `Django`
```bash
pip install django-scp
```

[Документация](https://django-csp.readthedocs.io/en/latest/decorators.html)

Устанавливаем приложение
```python
INSTALLED_APPS = (
    # ...
    "csp",
    # ...
```

Устанавливаем мидлварь
```python
MIDDLEWARE = [
    # ...
    'csp.middleware.CSPMiddleware',
    # ...
]
```

|Директива|Описание|Пример|
|---|---|---|
|`CSP_DEFAULT_SRC`|должен ли `django-csp` добавлять директиву default-src в каждый заголовок|`CSP_DEFAULT_SRC = ("'self'", )`|
|`CSP_INCLUDE_NONCE_IN`| с чем `django-csp` должен комбинировать источник nonce|`CSP_INCLUDE_NONCE_IN = ['script-src', 'style-src', ]`|
|`CSP_SCRIPT_SRC`|обработка JS в браузере|`CSP_SCRIPT_SRC = ("'self'", )`|
|`CSP_STYLE_SRC`|обработка CSS в браузере|`CSP_STYLE_SRC = ("'self'", )`|
|`CSP_IMG_SRC`|как браузер будет извлекать изображения|`CSP_IMG_SRC = ("'self'", 'https://cdn.charlie.com', )`|
|`CSP_FORM_ACTION`|куда пользователь может отправить форму|`CSP_FORM_ACTION = ("'self'", )`|
|`CSP_FRAME_ANCESTORS`|куда можно переадресовать пользователя|`CSP_FRAME_ANCESTORS = ("'none'", )`|

Добавление директивы `nonce` в ответ
```html
<script nonce='{{request.csp_nonce}}'>
/* встроенный сценарий */
</script>
```

Декораторы для управления политиками:
- `csp_update` добавляет значение в список источников
- `csp_replace` заменяет директиву для одного представления
- `csp ` заменяет всю политику для одного представления
- `csp_exempt` удаляет заголовок CSP для отдельного представления

Добавление отдельных политик в отдельный `View` без изменения глобальной политики
```python
# Will append cdn-img.com to the list of values for `img-src` in the report-only policy.
@csp_update({"img-src": "cdn-img.com"}, REPORT_ONLY=True)
def myview(request):
    return render(...)
```

#### CSRF
>[!info] Подделка межсайтовых запросов (`cross-site request forgery`, `CSRF`). Цель атак `CSRF` – заставить жертву отправить поддельный запрос на уязвимый веб-сайт. Противостояние атакам `CSRF` сводится к различению поддельных и благонамеренных запросов пользователя. В защищенных системах для этого используются заголовки запросов, заголовки ответов, cookie и соглашения об управлении состоянием.

Пример. Предположим, что Алиса развернула `admin.alice.com` – административный раздел для ее онлайн-банка. Как и другие административные системы, admin.alice.com позволяет администраторам, таким как Алиса, управлять членством в группах других пользователей. 
Например, Алиса может добавить кого-либо в группу, отправив выбранное имя пользователя и имя группы в `/group-membership/`.
Однажды Алиса получила текстовое сообщение от Мэллори, злонамеренного банковского служащего, содержащее ссылку на один из грабительских веб-сайтов Мэллори, `win-iphone.mallory.com`. Алиса попалась на приманку и перешла по ссылке на сайт Мэллори, который отобразил в ее браузере следующую HTML-страницу. Алиса не знала, что эта страница содержит форму с двумя скрытыми полями ввода. Мэллори предварительно заполнила эти поля своим именем пользователя и именем привилегированной группы. Для дальнейшего развития атаки от Алисы не требуется больше никаких действий. Обработчик событий для тега body (выделен жирным в следующем примере) автоматически отправляет форму сразу после загрузки страницы. Алиса, к этому моменту выполнившая вход на admin.alice.com, непреднамеренно добавляет Мэллори
в группу администраторов. Как администратор Мэллори теперь может злоупотребить своими новыми привилегиями.

![[new_csrf.png]]

###### SameSite
Директива `SameSite` в заголовке `Set-Cookie` информирует браузер, что отправлять cookie следует только в ответ на запросы с того же сайта.

```
Set-Cookie: sessionid=<session-id-value>; SameSite=None; ...
Set-Cookie: sessionid=<session-id-value>; SameSite=Strict; ...
Set-Cookie: sessionid=<session-id-value>; SameSite=Lax; ...
```

|Значение|Описание|
|---|---|
|`None`|Браузер отправит куки на сервер, с которого был получен этот запрос|
|`Strict`|Браузер отправит куки, только в ответ на запросы с того же сайта|
|`Lax`| Браузер отправит куки в ответ на все запросы с того же сайта, а также в ответ на запросы навигации верхнего уровня между сайтами с использованием безопасного метода HTTP, такого как GET|

Из всех методов запроса, определенных этой спецификацией, только `GET`, `HEAD`, `OPTIONS` и `TRACE` считаются безопасными. Следует понимать, что `GET` по настоящему безопасный только если сам сервер не обрабатывает `GET` как изменение состояния.
Методы запроса считаются «безопасными», если определяемая ими семантика предполагает доступ только для чтения; т. е. клиент не запрашивает и не ожидает каких-либо изменений состояния на сервере в результате применения безопасного метода к целевому ресурсу.

В Django этим управляет параметр `SESSION_COOKIE_SAMESITE`
```python
# settings.py
SESSION_COOKIE_SAMESITE = "Lax"
```

###### CSRF Токен
При установке в `True` токен может быть отправлен только по HTTPS (добавляет атрибут `Secure`)
```python
# settings.py
CSRF_COOKIE_SECURE=True
```

Для POST, PUT, PATCH, DELETE запросов в форме `Django` добавляем токен
```html
<html>
    <form method='POST'>
         {% csrf_token %}
         <table>
             {{ form.as_table }}
         </table>
         <input type='submit' value='Submit'>
    </form>
</html>
```

Получив запрос, `Django` извлекает токен из куки(`X-CSRFToken`) и парамет­ра. Запрос принимается, только если cookie и параметр совпадают. 

#### CORS (Cross-Origin Resource Sharing)
>[!info] Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент.

В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, XMLHttpRequest и Fetch API следуют _политике одного источника_. Это значит, что **web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены**, пока не будут использованы CORS-заголовки. Например с помощью этого механизма мы можем разрешить пользование нашим API только для тех клиентов, которым доверяем.

>[!info] Просто для информации, заголовок который отправляет наш бэкенд клиенту, должен выглядеть так:
>`Access-Control-Allow-Origin: https://frontend.example.com`

[Документация](https://pypi.org/project/django-cors-headers/)

Включение заголовков
```bash
pip install django-cors-headers
```

```python
INSTALLED_APPS = (
    ...
    'corsheaders',
    ...
)
```

```python
MIDDLEWARE = [
    ...,
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    ...,
]
```

```python
CORS_ALLOWED_ORIGINS = [
    'http://localhost:3030',
]
```

Для всех источников
```python
CORS_ALLOW_ALL_ORIGINS = True  # Access-Control-Allow-Origin: *
```

###### Предварительный запрос
![[new_cors_preflight.png]]
![[new_cors_req.png]]

Как потребитель ресурсов вы не несете ответственности за отправку предварительного запроса; как производитель ресурсов вы несете ответственность за отправку ответа на предварительный запрос.

Ответ на предварительный запрос.

|Заголовок|Настраивается с помощью|
|---|---|
|`Access-Control-Allow-Methods`|`CORS_ALLOW_METHODS`|
|`Access-Control-Allow-Headers`|`CORS_ALLOW_HEADERS`|
|`Access-Control-Max-Age`|`CORS_PREFLIGHT_MAX_AGE`|

Рекомедуется
```python
CORS_PREFLIGHT_MAX_AGE = 1 if DEBUG else 60
```

###### Отправка cookie между источниками
Чтобы отправить например `sessionid`, надо разрешить отправку куки с помощью заголовка `Access-Control-Allow-Credentials`. Он позволяет браузеру включать учетные данные в последующий запрос ресурса с другим источником. К учетным данным на стороне клиента относятся: cookie, заголовки авторизации и клиентские сертификаты TLS.
 
Требуемый заголовок
```
Access-Control-Allow-Credentials: true
```

Настраивается с помощью
```python
CORS_ALLOW_CREDENTIALS = True
```

>[!warning] Access-Control-Allow-Credentials разрешает браузеру отправлять cookie, но не заставляет делать что-либо.

Пример отправки с помощью JS
```html
<script>
    ...
    fetch('https://social.bob.com/comment/', {
        method: 'PUT',
        headers: headers,
        credentials: 'include',
        body: JSON.stringify(body)
    })
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error('error', error));
    ...
</script>
```

#### Кликджекинг
>[!info] Кликджекинг – это атака, суть которой состоит в заманивании жертвы на вредоносную веб-страницу, где ей предлагается щелкнуть на внешне безобидной ссылке или кнопке. Событие щелчка перехватывается злоумышленником и распространяется на другой элемент управления пользовательского интерфейса на ином сайте.

Пример. Мэллори решила обманом заставить Чарли запустить ракету. Она заманивает его на `win-iphone.mallory.com`, где его браузер отображает HTML-страницу. Роль приманки на этой странице играет кнопка, соблазняющая Чарли новым iPhone. Элемент `iframe` загружает `charlie.mil/launch-missile.html`. Встроенная таблица стилей отображает iframe прозрачным, устанавливая свойство `opacity` равным `0`. Кроме того, `iframe` размещается поверх кнопки-приманки с по­мощью свойства `z-index`. Такая организация гарантирует, что событие щелчка мышью получит прозрачный элемент управления, а не кнопка-приманка.

К сожалению, POST-запрос не блокируется политикой одного источника; CORS здесь не работает. Почему? Да просто потому, что это не межсайтовый запрос. Источник запроса определяется источником (charlie.mil) страницы, загруженной в iframe, а не источником (win-iphone.mallory.com) страницы, содержащей iframe.

Для защиты от кликджекинга сайты традиционно используют заголовок ответа `X-Frame-Options`. По умолчанию `Django` добавляет заголовок `X-Frame-Options` в каждый ответ.

CSP-директива `frame-ancestors` обеспечивает более точное управление чём устаревший `X-Frame-Options`
[[Безопасность web-приложений#Управление политиками `SCP` в `Django`]]